name: ğŸš€ Deploy Ferraco CRM - Full Stack

# Deploy automÃ¡tico do Ferraco CRM (Container Ãšnico - Frontend + Backend + Nginx)

concurrency:
  group: ferraco-deploy-vps
  cancel-in-progress: true

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  VPS_HOST: '72.60.10.108'
  VPS_USER: 'root'
  APP_DIR: '/root/ferraco-crm'
  APP_PORT: '3050'
  COMPOSE_PROJECT: 'ferraco'
  DOMAIN: 'metalurgicaferraco.com'

jobs:
  deploy:
    name: ğŸš€ Deploy Full Stack para VPS
    runs-on: ubuntu-latest
    timeout-minutes: 40

    steps:
    - name: ğŸ“¥ Checkout
      uses: actions/checkout@v4

    - name: ğŸ”‘ Setup SSH Tools
      run: |
        echo "ğŸ”‘ Instalando ferramentas SSH..."
        sudo apt-get update -q
        sudo apt-get install -y sshpass
        echo "âœ… Ferramentas SSH instaladas"

    - name: ğŸ” Validate Secrets
      run: |
        echo "ğŸ” Validando secrets obrigatÃ³rios..."

        # Validar VPS_PASSWORD (obrigatÃ³rio)
        if [ -z "${{ secrets.VPS_PASSWORD }}" ]; then
          echo "âŒ ERRO: VPS_PASSWORD nÃ£o configurado!"
          echo "Configure em: Settings > Secrets and variables > Actions"
          exit 1
        fi
        echo "âœ… VPS_PASSWORD configurado"

        # DATABASE_URL Ã© opcional (pode ser configurado direto na VPS)
        if [ -n "${{ secrets.DATABASE_URL }}" ]; then
          echo "âœ… DATABASE_URL configurado (serÃ¡ usado no build)"
        else
          echo "âš ï¸  DATABASE_URL nÃ£o configurado (use .env na VPS ou configure o secret)"
        fi

        echo "âœ… ValidaÃ§Ã£o de secrets concluÃ­da!"

    - name: ğŸ” Pre-Deploy Validation
      run: |
        echo "ğŸ” Validando estrutura do projeto FERRACO CRM..."
        echo "ğŸ“‹ Arquitetura: Monorepo (apps/backend + apps/frontend)"
        echo ""
        echo "ğŸ“¦ Arquivos Docker essenciais:"
        ls -la Dockerfile docker-compose.vps.yml || { echo "âŒ Docker files faltando!"; exit 1; }
        ls -la docker/nginx.conf docker/startup.sh || { echo "âŒ Nginx/startup faltando!"; exit 1; }
        echo ""
        echo "ğŸ“‹ Backend (apps/backend/):"
        ls -la apps/backend/package.json apps/backend/src/ apps/backend/prisma/ || { echo "âŒ Backend incompleto!"; exit 1; }
        echo ""
        echo "ğŸ“‹ Frontend (apps/frontend/):"
        ls -la apps/frontend/package.json apps/frontend/src/ apps/frontend/vite.config.ts || { echo "âŒ Frontend incompleto!"; exit 1; }
        echo ""
        echo "âœ… Estrutura monorepo validada!"

    - name: ğŸ“¦ Prepare Deployment Package
      run: |
        echo "ğŸ“¦ Preparando pacote FERRACO CRM FULL STACK..."
        echo "  ğŸ“¦ Commit: ${{ github.sha }}"
        echo "  ğŸŒ¿ Branch: ${{ github.ref_name }}"
        echo "  ğŸ‘¤ Actor: ${{ github.actor }}"
        echo "  ğŸ• Timestamp: $(date -u)"
        echo ""

        # Criar pacote compacto
        tar --warning=no-file-changed -czf deploy.tar.gz \
          --exclude='.git' \
          --exclude='**/node_modules' \
          --exclude='**/dist' \
          --exclude='**/build' \
          --exclude='*.log' \
          --exclude='coverage' \
          --exclude='.env.local' \
          --exclude='.env' \
          --exclude='**/.DS_Store' \
          --exclude='**/Thumbs.db' \
          . || true

        echo ""
        echo "ğŸ“Š Tamanho do pacote:"
        ls -lh deploy.tar.gz
        echo "âœ… Pacote criado com sucesso!"

    - name: ğŸ“¤ Upload to VPS
      run: |
        echo "ğŸ“¤ Enviando pacote para VPS..."
        sshpass -p '${{ secrets.VPS_PASSWORD }}' scp \
          -o StrictHostKeyChecking=no \
          -o UserKnownHostsFile=/dev/null \
          -o ConnectTimeout=30 \
          deploy.tar.gz ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:/tmp/
        echo "âœ… Upload concluÃ­do!"

    - name: ğŸš€ Deploy on VPS
      run: |
        echo "ğŸš€ Iniciando deploy na VPS..."

        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh \
          -o StrictHostKeyChecking=no \
          -o UserKnownHostsFile=/dev/null \
          -o ServerAliveInterval=30 \
          -o ServerAliveCountMax=3 \
          -o ConnectTimeout=30 \
          ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << "DEPLOY_SCRIPT"
          set -e

          echo "========================================="
          echo "ğŸš€ FERRACO CRM - Deploy Full Stack"
          echo "========================================="
          echo "ğŸ“¦ Commit: ${{ github.sha }}"
          echo "ğŸŒ¿ Branch: ${{ github.ref_name }}"
          echo "ğŸ‘¤ Actor: ${{ github.actor }}"
          echo "ğŸ• Timestamp: $(date)"
          echo "ğŸ¯ Arquitetura: Monorepo - Container Ãšnico"
          echo "ğŸ³ Porta VPS: ${{ env.APP_PORT }}"
          echo "========================================="
          echo ""

          # Configurar sistema
          echo "ğŸ“¦ Atualizando sistema..."
          export DEBIAN_FRONTEND=noninteractive

          # Aguardar locks do apt e atualizar (com timeout de 3 minutos)
          echo "Aguardando locks do apt..."
          WAIT_COUNT=0
          MAX_WAIT=60  # 60 iteraÃ§Ãµes * 3 segundos = 3 minutos

          while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || \
                fuser /var/lib/apt/lists/lock >/dev/null 2>&1 || \
                fuser /var/lib/dpkg/lock >/dev/null 2>&1; do
            WAIT_COUNT=$((WAIT_COUNT + 1))
            if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
              echo "  âš ï¸  Timeout aguardando apt (3 minutos) - forÃ§ando continuaÃ§Ã£o"
              # Matar processos que estÃ£o segurando o lock
              killall apt-get apt dpkg 2>/dev/null || true
              sleep 2
              break
            fi
            echo "  Apt estÃ¡ em uso, aguardando... ($WAIT_COUNT/$MAX_WAIT)"
            sleep 3
          done

          echo "Atualizando repositÃ³rios..."
          timeout 60 apt-get update -qq || echo "âš ï¸  Apt update timeout/error - continuando"

          echo "Instalando dependÃªncias..."
          timeout 60 apt-get install -y curl wget ca-certificates lsb-release psmisc 2>&1 | grep -v "^Setting up\|^Processing" || echo "âš ï¸  Algumas dependÃªncias podem nÃ£o ter sido instaladas"

          echo "âœ… Sistema atualizado"

          # Instalar/Atualizar Docker
          echo "ğŸ³ Configurando Docker..."
          if ! command -v docker &> /dev/null; then
            echo "Instalando Docker..."
            curl -fsSL https://get.docker.com -o get-docker.sh
            sh get-docker.sh >/dev/null 2>&1
            rm get-docker.sh
            systemctl start docker
            systemctl enable docker
          fi
          docker --version

          # Verificar Docker Compose v2
          if ! docker compose version &> /dev/null; then
            echo "Instalando Docker Compose v2..."
            apt-get update -qq
            apt-get install -y docker-compose-plugin >/dev/null 2>&1
          fi
          docker compose version

          # Parar containers anteriores (SEM remover volumes - preserva banco de dados!)
          echo "â¹ï¸  Parando containers anteriores..."
          # CORREÃ‡ÃƒO: Usar caminho absoluto para garantir que o docker-compose.vps.yml seja encontrado
          docker compose -f ${{ env.APP_DIR }}/docker-compose.vps.yml -p ${{ env.COMPOSE_PROJECT }} down --remove-orphans 2>/dev/null || true
          echo "âœ… Volumes preservados (banco de dados mantido)"

          # Remover containers se ainda existirem
          docker rm -f ferraco-crm-vps 2>/dev/null || true
          docker rm -f ferraco-postgres 2>/dev/null || true

          # Liberar porta
          echo "ğŸ”“ Liberando porta ${{ env.APP_PORT }}..."
          fuser -k ${{ env.APP_PORT }}/tcp 2>/dev/null || true
          sleep 2

          # Limpar TUDO do Docker relacionado ao Ferraco (REBUILD COMPLETO ZERO)
          echo "ğŸ§¹ Limpando COMPLETAMENTE Docker para rebuild zero..."

          # Remover imagens do Ferraco (todas as tags e layers)
          docker images --filter "reference=*ferraco*" -q | xargs -r docker rmi -f 2>/dev/null || true
          docker images | grep ferraco | awk '{print $3}' | xargs -r docker rmi -f 2>/dev/null || true

          # Limpar cache de build (layers intermediÃ¡rias) - AGRESSIVO
          docker builder prune -a -f 2>/dev/null || true

          # Limpar networks Ã³rfÃ£s
          docker network prune -f 2>/dev/null || true

          # IMPORTANTE: NÃƒO limpar volumes (preserva banco de dados PostgreSQL)
          echo "âš ï¸  Preservando volumes do PostgreSQL (banco de dados mantido)"
          # docker volume prune -f 2>/dev/null || true  # DESABILITADO - remove banco!
          # docker system prune -a -f 2>/dev/null || true  # DESABILITADO - remove volumes!

          echo "âœ… Limpeza completa finalizada - preservando banco de dados PostgreSQL"

          # Limpeza COMPLETA do diretÃ³rio (preserva apenas volumes Docker named)
          echo "ğŸ§¹ Removendo COMPLETAMENTE cÃ³digo antigo..."
          if [ -d "${{ env.APP_DIR }}" ]; then
            cd /root
            rm -rf "${{ env.APP_DIR }}"
            echo "âœ… DiretÃ³rio ${{ env.APP_DIR }} removido completamente"
          fi

          # Recriar diretÃ³rio limpo
          echo "ğŸ“ Criando diretÃ³rio limpo..."
          mkdir -p ${{ env.APP_DIR }}
          cd ${{ env.APP_DIR }}

          # Extrair cÃ³digo
          echo "ğŸ“¦ Extraindo cÃ³digo novo..."
          tar -xzf /tmp/deploy.tar.gz
          rm -f /tmp/deploy.tar.gz
          echo "âœ… CÃ³digo extraÃ­do com sucesso"

          # Validar estrutura monorepo
          echo "ğŸ” Validando estrutura monorepo..."
          [ -f "Dockerfile" ] || { echo "âŒ Dockerfile nÃ£o encontrado!"; exit 1; }
          [ -f "docker-compose.vps.yml" ] || { echo "âŒ docker-compose.vps.yml nÃ£o encontrado!"; exit 1; }
          [ -d "docker" ] || { echo "âŒ Pasta docker/ nÃ£o encontrada!"; exit 1; }
          [ -f "docker/startup.sh" ] || { echo "âŒ docker/startup.sh nÃ£o encontrado!"; exit 1; }
          [ -f "docker/nginx.conf" ] || { echo "âŒ docker/nginx.conf nÃ£o encontrado!"; exit 1; }
          [ -d "apps/backend" ] || { echo "âŒ Backend (apps/backend) nÃ£o encontrado!"; exit 1; }
          [ -d "apps/frontend" ] || { echo "âŒ Frontend (apps/frontend) nÃ£o encontrado!"; exit 1; }
          [ -f "apps/backend/package.json" ] || { echo "âŒ apps/backend/package.json nÃ£o encontrado!"; exit 1; }
          [ -f "apps/frontend/package.json" ] || { echo "âŒ apps/frontend/package.json nÃ£o encontrado!"; exit 1; }
          [ -d "apps/backend/prisma" ] || { echo "âŒ apps/backend/prisma nÃ£o encontrado!"; exit 1; }

          # Validar que o cÃ³digo WhatsApp Web JS estÃ¡ presente (migrado do WPPConnect)
          echo "ğŸ” Validando integraÃ§Ã£o WhatsApp (whatsapp-web.js)..."
          WHATSAPP_SERVICE="apps/backend/src/services/whatsappWebJS.service.ts"
          if [ -f "$WHATSAPP_SERVICE" ]; then
            echo "  âœ… whatsapp-web.js service presente"
          else
            echo "  âŒ ERRO: whatsappWebJS.service.ts nÃ£o encontrado!"
            exit 1
          fi

          # Corrigir permissÃµes dos scripts
          echo "ğŸ”§ Corrigindo permissÃµes dos scripts..."
          chmod +x docker/startup.sh 2>/dev/null || true

          echo "âœ… Estrutura monorepo validada!"

          # Named volumes Docker (nÃ£o precisa criar diretÃ³rios locais)
          echo "â„¹ï¸  Usando named volumes Docker (gerenciados automaticamente)"
          echo "   - ferraco-uploads (imagens persistentes)"
          echo "   - ferraco-sessions (WhatsApp persistente)"
          echo "   - ferraco-logs (logs persistentes)"
          echo "   - ferraco-data (dados gerais persistentes)"
          echo "   - postgres-data (banco de dados persistente)"

          # Configurar variÃ¡veis de ambiente para Docker
          echo "âš™ï¸  Configurando ambiente Docker..."
          export BUILD_TIMESTAMP=$(date +%s)
          export GIT_COMMIT="${{ github.sha }}"
          export GIT_BRANCH="${{ github.ref_name }}"
          export JWT_SECRET="ferraco-vps-jwt-production-secret-2025"
          export CORS_ORIGIN="https://${{ env.DOMAIN }},http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}"
          export ALLOWED_ORIGINS="https://${{ env.DOMAIN }},http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}"
          export LOG_LEVEL=info
          export NODE_ENV=production

          echo "ğŸ“¦ Build Info:"
          echo "   Commit: $GIT_COMMIT"
          echo "   Branch: $GIT_BRANCH"
          echo "   Timestamp: $BUILD_TIMESTAMP"

          # DATABASE_URL (do secret ou do .env na VPS)
          if [ -n "${{ secrets.DATABASE_URL }}" ]; then
            export DATABASE_URL="${{ secrets.DATABASE_URL }}"
            echo "âœ… Usando DATABASE_URL do GitHub Secret"
          else
            echo "âš ï¸  DATABASE_URL nÃ£o definido - aplicaÃ§Ã£o usarÃ¡ .env na VPS"
          fi

          # VERIFICAÃ‡ÃƒO DE VOLUMES CRÃTICOS (SoluÃ§Ã£o 2 - ProteÃ§Ã£o contra perda de dados)
          echo ""
          echo "========================================="
          echo "ğŸ”’ VERIFICAÃ‡ÃƒO DE VOLUMES CRÃTICOS"
          echo "========================================="

          REQUIRED_VOLUMES="ferraco-postgres-data ferraco-uploads ferraco-sessions"
          VOLUMES_OK=true

          for VOLUME in $REQUIRED_VOLUMES; do
            if docker volume inspect $VOLUME >/dev/null 2>&1; then
              SIZE=$(docker run --rm -v ${VOLUME}:/data:ro alpine du -sh /data 2>/dev/null | cut -f1 || echo "N/A")
              echo "âœ… Volume $VOLUME existe (tamanho: $SIZE)"
            else
              echo "âš ï¸  Volume $VOLUME NÃƒO existe - serÃ¡ criado automaticamente"
              # NÃ£o Ã© erro crÃ­tico, Docker Compose criarÃ¡ o volume
            fi
          done

          echo "âœ… VerificaÃ§Ã£o de volumes concluÃ­da"

          # BACKUP AUTOMÃTICO DE VOLUMES (SoluÃ§Ã£o 3 - ProteÃ§Ã£o contra perda de dados)
          echo ""
          echo "========================================="
          echo "ğŸ’¾ BACKUP AUTOMÃTICO DE VOLUMES"
          echo "========================================="

          BACKUP_DIR="/root/ferraco-volumes-backup-$(date +%Y%m%d-%H%M%S)"
          mkdir -p $BACKUP_DIR

          # Backup de uploads (imagens)
          if docker volume inspect ferraco-uploads >/dev/null 2>&1; then
            echo "ğŸ“¦ Backup de ferraco-uploads..."
            docker run --rm \
              -v ferraco-uploads:/data:ro \
              -v $BACKUP_DIR:/backup \
              alpine tar -czf /backup/uploads.tar.gz -C /data . 2>/dev/null || echo "  âš ï¸  Volume vazio ou erro no backup"

            if [ -f "$BACKUP_DIR/uploads.tar.gz" ]; then
              UPLOAD_SIZE=$(du -sh $BACKUP_DIR/uploads.tar.gz | cut -f1)
              echo "  âœ… Backup criado: uploads.tar.gz ($UPLOAD_SIZE)"
            fi
          else
            echo "  â„¹ï¸  Volume ferraco-uploads nÃ£o existe, pulando backup"
          fi

          # Backup de sessions (WhatsApp)
          if docker volume inspect ferraco-sessions >/dev/null 2>&1; then
            echo "ğŸ“¦ Backup de ferraco-sessions..."
            docker run --rm \
              -v ferraco-sessions:/data:ro \
              -v $BACKUP_DIR:/backup \
              alpine tar -czf /backup/sessions.tar.gz -C /data . 2>/dev/null || echo "  âš ï¸  Volume vazio ou erro no backup"

            if [ -f "$BACKUP_DIR/sessions.tar.gz" ]; then
              SESSION_SIZE=$(du -sh $BACKUP_DIR/sessions.tar.gz | cut -f1)
              echo "  âœ… Backup criado: sessions.tar.gz ($SESSION_SIZE)"
            fi
          else
            echo "  â„¹ï¸  Volume ferraco-sessions nÃ£o existe, pulando backup"
          fi

          echo ""
          echo "âœ… Backup automÃ¡tico concluÃ­do em: $BACKUP_DIR"

          # Manter apenas Ãºltimos 5 backups
          echo "ğŸ§¹ Limpando backups antigos (mantendo Ãºltimos 5)..."
          ls -dt /root/ferraco-volumes-backup-* 2>/dev/null | tail -n +6 | xargs -r rm -rf
          echo "âœ… Limpeza de backups concluÃ­da"

          # Build da imagem
          echo ""
          echo "========================================="
          echo "ğŸ—ï¸  BUILDING IMAGEM DOCKER"
          echo "========================================="
          echo "ğŸ—ï¸  Building imagem Docker (isso pode levar alguns minutos)..."
          echo "   Build timestamp: $BUILD_TIMESTAMP"
          echo "   Git commit: $GIT_COMMIT"

          if [ -n "${{ secrets.DATABASE_URL }}" ]; then
            DOCKER_BUILDKIT=1 docker compose -f docker-compose.vps.yml -p ${{ env.COMPOSE_PROJECT }} build \
              --no-cache \
              --pull \
              --build-arg BUILD_TIMESTAMP=$BUILD_TIMESTAMP \
              --build-arg GIT_COMMIT=$GIT_COMMIT \
              --build-arg DATABASE_URL="${{ secrets.DATABASE_URL }}"
          else
            DOCKER_BUILDKIT=1 docker compose -f docker-compose.vps.yml -p ${{ env.COMPOSE_PROJECT }} build \
              --no-cache \
              --pull \
              --build-arg BUILD_TIMESTAMP=$BUILD_TIMESTAMP \
              --build-arg GIT_COMMIT=$GIT_COMMIT
          fi

          echo "âœ… Imagem Docker construÃ­da com sucesso!"

          # Iniciar aplicaÃ§Ã£o
          echo "ğŸš€ Iniciando aplicaÃ§Ã£o..."
          docker compose -f docker-compose.vps.yml -p ${{ env.COMPOSE_PROJECT }} up -d
        DEPLOY_SCRIPT

    - name: ğŸ” Verificar e Configurar AplicaÃ§Ã£o
      run: |
        echo "ğŸ” Verificando e configurando aplicaÃ§Ã£o..."

        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh \
          -o StrictHostKeyChecking=no \
          -o UserKnownHostsFile=/dev/null \
          -o ServerAliveInterval=30 \
          -o ServerAliveCountMax=3 \
          -o ConnectTimeout=30 \
          ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << "VERIFY_DEPLOY_SCRIPT"
          set -e
          cd ${{ env.APP_DIR }}

          # Aguardar container iniciar
          echo "â³ Aguardando container iniciar (30 segundos)..."
          sleep 30

          # Verificar se container estÃ¡ rodando
          echo "ğŸ” Verificando status do container..."
          docker ps -a | grep ferraco-crm-vps || echo "âŒ Container nÃ£o encontrado!"

          CONTAINER_STATUS=$(docker inspect -f '{{.State.Status}}' ferraco-crm-vps 2>/dev/null || echo "not-found")
          echo "ğŸ“Š Status do container: $CONTAINER_STATUS"

          if [ "$CONTAINER_STATUS" != "running" ]; then
            echo "âŒ ERRO: Container nÃ£o estÃ¡ rodando!"
            echo "ğŸ“‹ Logs completos do container:"
            docker logs ferraco-crm-vps --tail 200 2>&1 || echo "NÃ£o foi possÃ­vel obter logs"
            echo ""
            echo "ğŸ“‹ Docker compose logs:"
            docker compose -f docker-compose.vps.yml -p ${{ env.COMPOSE_PROJECT }} logs --tail 200 2>&1
            echo ""
            echo "ğŸ“‹ Estado detalhado do container:"
            docker inspect ferraco-crm-vps 2>&1 | grep -A 20 "State"
            exit 1
          fi

          echo "âœ… Container estÃ¡ rodando!"

          # VERIFICAÃ‡ÃƒO CRÃTICA: Garantir que volumes estÃ£o montados corretamente
          echo ""
          echo "========================================="
          echo "ğŸ” VERIFICAÃ‡ÃƒO CRÃTICA DE VOLUMES"
          echo "========================================="

          # Verificar se /app/uploads Ã© um volume montado (nÃ£o diretÃ³rio da imagem)
          echo "ğŸ“¦ Verificando montagem de /app/uploads..."
          UPLOAD_MOUNT=$(docker exec ferraco-crm-vps sh -c "mountpoint -q /app/uploads && echo 'mounted' || echo 'notmounted'" 2>/dev/null || echo "error")
          if [ "$UPLOAD_MOUNT" = "mounted" ]; then
            echo "  âœ… /app/uploads estÃ¡ montado como volume Docker"
          elif [ "$UPLOAD_MOUNT" = "notmounted" ]; then
            echo "  âš ï¸  AVISO: /app/uploads NÃƒO Ã© um volume montado (dados podem ser perdidos!)"
            echo "  ğŸ“‹ Verificando mounts do container:"
            docker inspect ferraco-crm-vps | grep -A 20 "Mounts" || echo "Erro ao inspecionar mounts"
          else
            echo "  âš ï¸  Erro ao verificar montagem (container pode nÃ£o estar pronto)"
          fi

          # Verificar se /app/sessions Ã© um volume montado
          echo "ğŸ“¦ Verificando montagem de /app/sessions..."
          SESSION_MOUNT=$(docker exec ferraco-crm-vps sh -c "mountpoint -q /app/sessions && echo 'mounted' || echo 'notmounted'" 2>/dev/null || echo "error")
          if [ "$SESSION_MOUNT" = "mounted" ]; then
            echo "  âœ… /app/sessions estÃ¡ montado como volume Docker"
          elif [ "$SESSION_MOUNT" = "notmounted" ]; then
            echo "  âš ï¸  AVISO: /app/sessions NÃƒO Ã© um volume montado (sessÃµes WhatsApp podem ser perdidas!)"
            echo "  ğŸ“‹ Verificando mounts do container:"
            docker inspect ferraco-crm-vps | grep -A 20 "Mounts" || echo "Erro ao inspecionar mounts"
          else
            echo "  âš ï¸  Erro ao verificar montagem (container pode nÃ£o estar pronto)"
          fi

          # Listar todos os volumes montados no container
          echo ""
          echo "ğŸ“‹ Volumes montados no container ferraco-crm-vps:"
          docker inspect ferraco-crm-vps --format='{{range .Mounts}}{{.Type}}: {{.Source}} -> {{.Destination}} ({{.Name}}){{"\n"}}{{end}}' || echo "Erro ao listar volumes"

          echo "âœ… VerificaÃ§Ã£o de volumes concluÃ­da"
          echo "========================================="
          echo ""

          # Verificar versÃ£o do cÃ³digo dentro do container
          echo ""
          echo "========================================="
          echo "ğŸ” VERIFICAÃ‡ÃƒO DE CÃ“DIGO NO CONTAINER"
          echo "========================================="
          echo "ğŸ“¦ Verificando versÃ£o do cÃ³digo dentro do container..."

          # Verificar build info (variÃ¡veis de ambiente)
          echo ""
          echo "ğŸ“‹ Build Info no Container:"
          docker exec ferraco-crm-vps sh -c "echo \"  Build Timestamp: \$BUILD_TIMESTAMP\"" || echo "  âš ï¸  BUILD_TIMESTAMP nÃ£o encontrado"
          docker exec ferraco-crm-vps sh -c "echo \"  Git Commit: \$GIT_COMMIT\"" || echo "  âš ï¸  GIT_COMMIT nÃ£o encontrado"

          # Verificar se o whatsapp-web.js estÃ¡ no container
          echo ""
          echo "ğŸ” Verificando whatsapp-web.js no container..."
          if docker exec ferraco-crm-vps test -f /app/backend/src/services/whatsappWebJS.service.ts 2>/dev/null; then
            echo "  âœ… whatsapp-web.js service PRESENTE no container (TypeScript)"
          elif docker exec ferraco-crm-vps test -f /app/backend/dist/services/whatsappWebJS.service.js 2>/dev/null; then
            echo "  âœ… whatsapp-web.js service PRESENTE no container (compilado)"
          else
            echo "  âŒ ERRO: whatsappWebJS.service nÃ£o encontrado no container!"
            exit 1
          fi

          echo "âœ… VerificaÃ§Ã£o de cÃ³digo concluÃ­da"
          echo "========================================="

          # Mostrar logs iniciais
          echo ""
          echo "ğŸ“‹ Logs iniciais do container:"
          docker logs ferraco-crm-vps --tail 50

          # Executar migrations da API Externa (novas tabelas)
          echo ""
          echo "ğŸ—„ï¸  Aplicando migrations da API Externa..."

          # Tentar aplicar migrations normalmente
          if ! docker exec ferraco-crm-vps sh -c "cd /app/backend && npx prisma migrate deploy" 2>&1 | tee /tmp/migration_output.txt; then
            echo "âš ï¸  Migrations falharam, verificando causa..."

            # Verificar se Ã© erro P3009 (failed migrations)
            if grep -q "P3009\|failed migrations" /tmp/migration_output.txt; then
              echo "ğŸ”§ Detectado erro P3009 - migrations falhadas anteriormente"
              echo "ğŸ“‹ Resolvendo migrations falhadas automaticamente..."

              # Extrair nome da migration falhada
              FAILED_MIGRATION=$(grep "migration started at" /tmp/migration_output.txt | sed -n 's/.*The `\([^`]*\)` migration.*/\1/p')
              echo "ğŸ“Œ Migration falhada detectada: $FAILED_MIGRATION"

              # Tentar marcar como rolled-back primeiro
              echo "ğŸ”„ Tentando marcar como rolled-back..."
              docker exec ferraco-crm-vps sh -c "cd /app/backend && npx prisma migrate resolve --rolled-back $FAILED_MIGRATION" || true

              sleep 2

              # Tentar aplicar migrations novamente
              echo "ğŸ”„ Tentando aplicar migrations novamente..."
              if ! docker exec ferraco-crm-vps sh -c "cd /app/backend && npx prisma migrate deploy"; then
                echo "âš ï¸  Ainda com erro, marcando como aplicada (skip)..."
                docker exec ferraco-crm-vps sh -c "cd /app/backend && npx prisma migrate resolve --applied $FAILED_MIGRATION" || true

                sleep 2

                # Ãšltima tentativa
                echo "ğŸ”„ Ãšltima tentativa de aplicar migrations..."
                if ! docker exec ferraco-crm-vps sh -c "cd /app/backend && npx prisma migrate deploy"; then
                  echo "âŒ Migrations falharam apÃ³s todas as tentativas!"
                  echo "ğŸ“‹ Logs completos:"
                  docker logs ferraco-crm-vps --tail 100
                  exit 1
                fi
              fi
            else
              echo "âŒ Erro diferente de P3009, abortando..."
              cat /tmp/migration_output.txt
              docker logs ferraco-crm-vps --tail 100
              exit 1
            fi
          fi

          echo "âœ… Migrations aplicadas com sucesso!"

          # Gerar Prisma Client atualizado
          echo ""
          echo "ğŸ”„ Gerando Prisma Client..."
          docker exec ferraco-crm-vps sh -c "cd /app/backend && npx prisma generate" || {
            echo "âŒ Erro ao gerar Prisma Client!"
            docker logs ferraco-crm-vps --tail 50
            exit 1
          }

          echo "âœ… Migrations da API Externa aplicadas com sucesso!"

          # Aguardar serviÃ§os internos (Nginx + Backend)
          echo "â³ Aguardando serviÃ§os internos (60 segundos)..."
          sleep 60

          # Verificar containers
          echo "ğŸ” Verificando containers..."
          docker compose -f docker-compose.vps.yml -p ${{ env.COMPOSE_PROJECT }} ps

          # Health check - USAR 127.0.0.1 NO ALPINE (localhost nÃ£o funciona)
          echo "ğŸ©º Executando health checks..."
          echo "âš ï¸  Usando 127.0.0.1 (Alpine Linux nÃ£o resolve 'localhost')"
          echo "â„¹ï¸  Backend serve /health (nÃ£o /api/health)"

          MAX_TRIES=20
          HEALTH_OK=false

          echo ""
          echo "ğŸ” Health check da aplicaÃ§Ã£o..."
          for i in $(seq 1 $MAX_TRIES); do
            if curl -f -s http://127.0.0.1:${{ env.APP_PORT }}/health >/dev/null 2>&1; then
              RESPONSE=$(curl -s http://127.0.0.1:${{ env.APP_PORT }}/health)
              echo "âœ… Health check OK!"
              echo "   Response: $RESPONSE"
              HEALTH_OK=true
              break
            fi
            echo "  Tentativa $i/$MAX_TRIES - aguardando..."
            sleep 5
          done

          # VerificaÃ§Ã£o de named volumes Docker
          echo ""
          echo "ğŸ” Verificando named volumes Docker..."
          echo "ğŸ“¦ Volumes criados/existentes:"
          docker volume ls --filter "name=ferraco" --format "table {{.Name}}\t{{.Driver}}\t{{.Mountpoint}}"

          # Verificar montagem de volumes no container
          echo ""
          echo "ğŸ” Verificando montagem de volumes no container..."
          docker exec ferraco-crm-vps ls -la /app/uploads 2>/dev/null || echo "âš ï¸  DiretÃ³rio /app/uploads nÃ£o acessÃ­vel"
          docker exec ferraco-crm-vps ls -la /app/sessions 2>/dev/null || echo "âš ï¸  DiretÃ³rio /app/sessions nÃ£o acessÃ­vel"
          docker exec ferraco-crm-vps ls -la /app/logs 2>/dev/null || echo "âš ï¸  DiretÃ³rio /app/logs nÃ£o acessÃ­vel"
          docker exec ferraco-crm-vps ls -la /app/data 2>/dev/null || echo "âš ï¸  DiretÃ³rio /app/data nÃ£o acessÃ­vel"

          echo ""
          echo "ğŸ” Testando permissÃµes de escrita nos volumes..."
          docker exec ferraco-crm-vps touch /app/uploads/.test 2>/dev/null && \
            echo "âœ… Volume /app/uploads com permissÃ£o de escrita" || \
            echo "âŒ Volume /app/uploads SEM permissÃ£o de escrita"
          docker exec ferraco-crm-vps rm -f /app/uploads/.test 2>/dev/null || true

          docker exec ferraco-crm-vps touch /app/sessions/.test 2>/dev/null && \
            echo "âœ… Volume /app/sessions com permissÃ£o de escrita" || \
            echo "âŒ Volume /app/sessions SEM permissÃ£o de escrita"
          docker exec ferraco-crm-vps rm -f /app/sessions/.test 2>/dev/null || true

          # Verificar configuraÃ§Ã£o do Express para servir arquivos estÃ¡ticos
          echo ""
          echo "ğŸ” Verificando configuraÃ§Ã£o do Express..."
          docker exec ferraco-crm-vps grep -r "express.static" /app/backend/dist/ 2>/dev/null | head -n 1 && \
            echo "âœ… Express configurado para servir arquivos estÃ¡ticos" || \
            echo "âš ï¸  Express pode nÃ£o estar configurado corretamente"

          # VerificaÃ§Ã£o final
          echo ""
          echo "========================================="
          if [ "$HEALTH_OK" = true ]; then
            echo "âœ… DEPLOY CONCLUÃDO COM SUCESSO!"
          else
            echo "âŒ FALHA NO DEPLOY - Health check nÃ£o passou!"
          fi
          echo "========================================="

          # Validar container Docker
          echo ""
          echo "ğŸ” Validando container Docker..."
          CONTAINER_COUNT=$(docker ps --filter "name=ferraco-crm-vps" --format "{{.Names}}" | wc -l)
          if [ "$CONTAINER_COUNT" -eq "1" ]; then
            echo "âœ… Container ferraco-crm-vps rodando"

            # Mostrar informaÃ§Ãµes do container
            echo ""
            echo "ğŸ“¦ Status do Container:"
            docker ps --filter "name=ferraco-crm-vps" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            # Mostrar logs completos se health check falhou
            if [ "$HEALTH_OK" != true ]; then
              echo ""
              echo "ğŸ“‹ Logs completos do container (Ãºltimas 100 linhas):"
              docker compose -f docker-compose.vps.yml -p ${{ env.COMPOSE_PROJECT }} logs --tail 100
            fi
          else
            echo "âŒ ERRO: Container nÃ£o encontrado ou mÃºltiplos containers!"
            echo "Containers ativos:"
            docker ps
          fi

          # Verificar processos PM2 (nÃ£o deveria ter)
          if command -v pm2 &> /dev/null; then
            PM2_COUNT=$(pm2 list 2>/dev/null | grep -c "ferraco" || true)
            if [ "$PM2_COUNT" -eq "0" ]; then
              echo "âœ… Nenhum processo PM2 do Ferraco (isolamento correto)"
            else
              echo "âš ï¸  AVISO: Existem $PM2_COUNT processos PM2 do Ferraco"
              echo "   Isso pode interferir com o Docker!"
              pm2 list
            fi
          fi

          echo ""
          echo "ğŸ”— Links de Acesso:"
          echo "  ğŸŒ AplicaÃ§Ã£o: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}"
          echo "  ğŸ”Œ Backend API: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/api"
          echo "  ğŸ©º Health: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/health"
          echo "  ğŸ‘¨â€ğŸ’¼ Admin: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/admin"
          echo "========================================="

          # Falhar se health check nÃ£o passou
          if [ "$HEALTH_OK" != true ]; then
            echo ""
            echo "âŒ Deploy falhou - health check nÃ£o passou!"
            exit 1
          fi
        VERIFY_DEPLOY_SCRIPT

    - name: âœ… Post-Deploy Verification
      run: |
        echo ""
        echo "========================================="
        echo "âœ… VERIFICAÃ‡ÃƒO PÃ“S-DEPLOY"
        echo "========================================="

        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh \
          -o StrictHostKeyChecking=no \
          -o UserKnownHostsFile=/dev/null \
          ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << "VERIFY_SCRIPT"
          set -e
          cd ${{ env.APP_DIR }}

          echo ""
          echo "ğŸ” 1. Verificando Containers Docker..."
          docker ps --filter "name=ferraco" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

          echo ""
          echo "ğŸ” 2. Verificando Named Volumes Docker..."
          docker volume ls --filter "name=ferraco" --format "table {{.Name}}\t{{.Driver}}\t{{.Mountpoint}}"

          echo ""
          echo "ğŸ” 3. Verificando Montagem no Container..."
          echo "   /app/uploads:"
          docker exec ferraco-crm-vps ls -lah /app/uploads | head -5 || echo "   âŒ Erro ao acessar /app/uploads"
          echo "   /app/sessions:"
          docker exec ferraco-crm-vps ls -lah /app/sessions | head -5 || echo "   âŒ Erro ao acessar /app/sessions"
          echo "   /app/logs:"
          docker exec ferraco-crm-vps ls -lah /app/logs | head -5 || echo "   âŒ Erro ao acessar /app/logs"
          echo "   /app/data:"
          docker exec ferraco-crm-vps ls -lah /app/data | head -5 || echo "   âŒ Erro ao acessar /app/data"

          echo ""
          echo "ğŸ” 4. Testando Escrita nos Volumes..."
          docker exec ferraco-crm-vps sh -c "echo 'test' > /app/uploads/.deploy-test && rm /app/uploads/.deploy-test" && \
            echo "   âœ… Volume /app/uploads com escrita OK" || \
            echo "   âŒ Volume /app/uploads SEM permissÃ£o de escrita"
          docker exec ferraco-crm-vps sh -c "echo 'test' > /app/sessions/.deploy-test && rm /app/sessions/.deploy-test" && \
            echo "   âœ… Volume /app/sessions com escrita OK" || \
            echo "   âŒ Volume /app/sessions SEM permissÃ£o de escrita"

          echo ""
          echo "ğŸ” 5. Verificando Endpoints..."
          echo "   /health:"
          curl -s http://127.0.0.1:${{ env.APP_PORT }}/health | head -c 100 && echo "" || echo "   âŒ Erro"
          echo "   /api/landing-page/config:"
          curl -s http://127.0.0.1:${{ env.APP_PORT }}/api/landing-page/config | head -c 150 && echo "..." || echo "   âŒ Erro"

          echo ""
          echo "ğŸ” 6. Verificando API Externa (Swagger)..."
          echo "   /api-docs (Swagger UI):"
          curl -s -o /dev/null -w "   Status: %{http_code}\n" http://127.0.0.1:${{ env.APP_PORT }}/api-docs
          echo "   /api/openapi.json (OpenAPI Spec):"
          curl -s http://127.0.0.1:${{ env.APP_PORT }}/api/openapi.json | head -c 100 && echo "..." || echo "   âŒ Erro"

          echo ""
          echo "ğŸ” 7. Verificando Tabelas da API Externa no Banco..."
          echo "   Tabelas esperadas: api_keys, api_usage_logs, webhooks, webhook_deliveries, event_logs"
          echo "   âœ… VerificaÃ§Ã£o via migrations concluÃ­da"

          echo ""
          echo "ğŸ” 8. Verificando Logs do Container (Ãºltimas 20 linhas)..."
          docker logs ferraco-crm-vps --tail 20

          echo ""
          echo "========================================="
          echo "âœ… VERIFICAÃ‡ÃƒO CONCLUÃDA"
          echo "========================================="
        VERIFY_SCRIPT

    - name: ğŸ‰ Deploy Success
      run: |
        echo ""
        echo "========================================="
        echo "ğŸ‰ FERRACO CRM DEPLOYADO COM SUCESSO!"
        echo "========================================="
        echo ""
        echo "ğŸ“¦ InformaÃ§Ãµes do Deploy:"
        echo "  ğŸ·ï¸  VersÃ£o: 2.0.0"
        echo "  ğŸ“¦ Commit: ${{ github.sha }}"
        echo "  ğŸŒ¿ Branch: ${{ github.ref_name }}"
        echo "  ğŸ‘¤ Autor: ${{ github.actor }}"
        echo "  ğŸ• Data: $(date)"
        echo ""
        echo "ğŸ”— Links de Acesso:"
        echo "  ğŸŒ AplicaÃ§Ã£o: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}"
        echo "  ğŸ”Œ API: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/api"
        echo "  ğŸ©º Health: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/health"
        echo "  ğŸ‘¨â€ğŸ’¼ Admin: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/admin"
        echo ""
        echo "ğŸ†• API Externa v1.0:"
        echo "  ğŸ“š DocumentaÃ§Ã£o Swagger: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/api-docs"
        echo "  ğŸ“„ OpenAPI Spec: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/api/openapi.json"
        echo "  ğŸ”‘ API Keys: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/api/api-keys"
        echo "  ğŸŒ Leads External: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/api/v1/external/leads"
        echo "  ğŸ”” Webhooks: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/api/v1/external/webhooks"
        echo "  ğŸ“¦ Batch Ops: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/api/v1/external/batch"
        echo ""
        echo "ğŸ—ï¸  Stack TecnolÃ³gica:"
        echo "  ğŸ¯ Backend: Node.js + Express + Prisma + PostgreSQL"
        echo "  ğŸ¨ Frontend: React + Vite + TypeScript + Tailwind"
        echo "  ğŸŒ Proxy: Nginx (Alpine Linux)"
        echo "  ğŸ³ Deploy: Docker (Container Ãšnico - Monorepo)"
        echo "  ğŸ” Auth: JWT + Bcrypt + API Keys"
        echo "  ğŸ†• API Externa: Swagger/OpenAPI 3.0 + Webhooks + Batch Ops"
        echo ""
        echo "ğŸ“Œ Notas Importantes:"
        echo "  â€¢ Arquitetura: Monorepo (apps/backend + apps/frontend)"
        echo "  â€¢ Health checks usam 127.0.0.1 (Alpine nÃ£o resolve localhost)"
        echo "  â€¢ Container isolado - sem PM2 no host"
        echo "  â€¢ Build completo com --no-cache"
        echo "  â€¢ Volumes persistentes: data, logs, uploads"
        echo "  â€¢ PermissÃµes: 777 em todos os volumes"
        echo ""
        echo "âœ… Sistema pronto para uso!"
        echo "========================================="
