/**
 * WhatsApp Service - Integração com WPPConnect
 *
 * Migrado de Venom Bot para WPPConnect para resolver problemas de:
 * - QR Code não sendo gerado em modo headless/Docker
 * - Instabilidade de conexão
 * - Loops infinitos de reconexão
 *
 * WPPConnect oferece:
 * ✅ QR Code confiável em headless
 * ✅ Callbacks estáveis
 * ✅ Melhor suporte para produção
 * ✅ Documentação clara
 */

import * as wppconnect from '@wppconnect-team/wppconnect';
import type { Whatsapp, Message, GroupProperty } from '@wppconnect-team/wppconnect';
import { logger } from '../utils/logger';
import * as path from 'path';
import * as fs from 'fs';
import whatsappChatService from './whatsappChatService';
import { WhatsAppListeners } from './whatsappListeners';
import { Server as SocketIOServer } from 'socket.io';

interface WhatsAppMessage {
  from: string;
  to: string;
  body: string;
  timestamp: Date;
  isGroup: boolean;
  fromMe: boolean;
}

class WhatsAppService {
  private client: Whatsapp | null = null;
  private qrCode: string | null = null;
  private isConnected: boolean = false;
  private sessionsPath: string;
  private isInitializing: boolean = false;
  private listeners: WhatsAppListeners | null = null;
  private pollingInterval: NodeJS.Timeout | null = null;
  private isPolling: boolean = false;
  private io: SocketIOServer | null = null; // ✅ FASE 2: Socket.IO instance

  constructor() {
    // Diretório de sessões (será volume Docker)
    this.sessionsPath = process.env.WHATSAPP_SESSIONS_PATH || path.join(process.cwd(), 'sessions');

    // Criar diretório se não existir
    if (!fs.existsSync(this.sessionsPath)) {
      fs.mkdirSync(this.sessionsPath, { recursive: true });
      logger.info(`📁 Diretório de sessões criado: ${this.sessionsPath}`);
    }
  }

  /**
   * Helper para garantir que o cliente está inicializado
   */
  private ensureClient(): Whatsapp {
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }
    return this.client;
  }

  /**
   * ✅ FASE 2: Configurar Socket.IO para eventos em tempo real
   */
  setSocketIO(io: SocketIOServer): void {
    this.io = io;
    logger.info('✅ Socket.IO configurado no WhatsAppService');

    // Listener para solicitar status/QR via Socket.IO
    this.io.on('connection', (socket) => {
      logger.info(`🔌 Cliente Socket.IO conectado: ${socket.id}`);

      // Cliente solicitou status atual
      socket.on('whatsapp:request-status', () => {
        logger.info('📡 Cliente solicitou status via Socket.IO');
        this.emitStatus();
      });

      // Cliente solicitou QR Code
      socket.on('whatsapp:request-qr', () => {
        logger.info('📡 Cliente solicitou QR Code via Socket.IO');
        if (this.qrCode) {
          socket.emit('whatsapp:qr', this.qrCode);
        }
      });
    });
  }

  /**
   * ✅ FASE 2: Emitir status atual via Socket.IO
   */
  private emitStatus(): void {
    if (!this.io) return;

    const status = this.isConnected ? 'CONNECTED' : (this.isInitializing ? 'INITIALIZING' : 'DISCONNECTED');
    this.io.emit('whatsapp:status', status);
    logger.info(`📡 Status emitido via Socket.IO: ${status}`);
  }

  /**
   * ✅ FASE 2: Emitir QR Code via Socket.IO
   */
  private emitQRCode(qrCode: string): void {
    if (!this.io) return;

    this.io.emit('whatsapp:qr', qrCode);
    logger.info('📡 QR Code emitido via Socket.IO');
  }

  /**
   * ✅ FASE 2: Emitir evento de conexão pronta via Socket.IO
   */
  private emitReady(): void {
    if (!this.io) return;

    this.io.emit('whatsapp:ready');
    this.io.emit('whatsapp:status', 'CONNECTED');
    logger.info('📡 WhatsApp pronto - evento emitido via Socket.IO');
  }

  /**
   * ✅ FASE 2: Emitir evento de desconexão via Socket.IO
   */
  private emitDisconnected(reason: string): void {
    if (!this.io) return;

    this.io.emit('whatsapp:disconnected', reason);
    this.io.emit('whatsapp:status', 'DISCONNECTED');
    logger.info(`📡 WhatsApp desconectado - evento emitido via Socket.IO: ${reason}`);
  }

  /**
   * Inicializar sessão WhatsApp
   * NÃO BLOQUEIA - Retorna imediatamente e conecta em background
   */
  async initialize(): Promise<void> {
    if (this.isInitializing) {
      logger.warn('⚠️  WhatsApp já está inicializando...');
      return;
    }

    logger.info('🚀 Inicializando WhatsApp com WPPConnect em background...');
    this.isInitializing = true;

    // Inicializar em background sem bloquear o servidor
    this.startWhatsAppClient().catch((error) => {
      logger.error('❌ Erro fatal ao inicializar WhatsApp:', error);
      this.isInitializing = false;
    });

    // Retornar imediatamente para não bloquear o servidor
    return Promise.resolve();
  }

  /**
   * Inicia o cliente WhatsApp (executa em background)
   */
  private async startWhatsAppClient(): Promise<void> {
    try {
      this.client = await wppconnect.create(
        'ferraco-crm', // session name
        // Callback QR Code
        (base64Qrimg: string, asciiQR: string, attempt: number) => {
          this.qrCode = base64Qrimg;
          logger.info(`📱 QR Code gerado! Tentativa ${attempt}`);
          logger.info('✅ Acesse /api/whatsapp/qr para visualizar o QR Code');

          // ✅ FASE 2: Emitir QR Code via Socket.IO
          this.emitQRCode(base64Qrimg);

          // QR code é regenerado automaticamente pelo WPPConnect
          // Não anular o código, sempre manter o mais recente disponível
        },
        // ✅ DEPRECATED: Callback antigo (manter para compatibilidade)
        // Use onStateChange() para novo código
        (statusSession: string, session: string) => {
          logger.debug(`📊 [${session}] Status Callback (legacy): ${statusSession}`);
          // Processamento agora feito em onStateChange()
        },
        undefined, // onLoadingScreen
        undefined, // catchLinkCode
        // Options
        {
          headless: 'new' as any,
          devtools: false,
          debug: false,
          disableWelcome: true,
          updatesLog: false,
          autoClose: 0,
          folderNameToken: this.sessionsPath,
          mkdirFolderToken: '',
          logQR: false,
          puppeteerOptions: {
            headless: 'new' as any,
            args: [
              '--no-sandbox',
              '--disable-setuid-sandbox',
              '--disable-dev-shm-usage',
              '--disable-accelerated-2d-canvas',
              '--no-first-run',
              '--no-zygote',
              '--disable-gpu',
              '--disable-software-rasterizer',
              '--disable-extensions',
            ],
          },
        }
      );

      // ✅ REFATORADO: Listeners nativos
      this.setupStateChangeListener();      // onStateChange (NOVO)
      this.setupMessageListeners();         // onAnyMessage (REFATORADO)
      this.setupAckListeners();             // onAck (mantido)
      this.setupPresenceListener();         // onPresenceChanged (NOVO)

      // Configurar listeners avançados (presença, digitando, chamadas, etc.)
      this.listeners = new WhatsAppListeners(this.client);
      this.listeners.setupAllListeners();
      this.listeners.setupPollListeners();
      this.listeners.setupDownloadListeners();
      this.listeners.setupSyncListeners();
      this.listeners.setupBatteryListeners();

      // ⭐ FASE 1: Configurar Phone Watchdog (monitoramento de conexão)
      this.setupPhoneWatchdog();

      logger.info('✅ WhatsApp Service (WPPConnect) inicializado!');
      this.isInitializing = false;

    } catch (error: any) {
      const errorMsg = error?.message || error?.toString() || String(error);

      logger.error('❌ Erro ao inicializar WhatsApp:', {
        error: errorMsg,
        stack: error?.stack,
      });

      this.isConnected = false;
      this.isInitializing = false;
    }
  }

  /**
   * ✅ NOVO: Listener nativo onStateChange (substitui callback de status)
   * Monitora mudanças de estado da conexão (CONNECTED, DISCONNECTED, etc)
   */
  private setupStateChangeListener(): void {
    if (!this.client) {
      logger.error('Cliente WhatsApp não inicializado');
      return;
    }

    // ✅ NATIVO: onStateChange com enums tipados
    this.client.onStateChange((state: any) => {
      logger.info(`🔄 Estado da conexão: ${state}`);

      // Mapear estados para comportamento
      switch (state) {
        case 'CONNECTED':
        case 'OPENING':
          this.isConnected = true;
          this.qrCode = null;
          this.isInitializing = false;
          logger.info('✅ WhatsApp conectado com sucesso!');
          this.emitReady();
          break;

        case 'DISCONNECTED':
        case 'TIMEOUT':
          this.isConnected = false;
          logger.warn('⚠️  WhatsApp desconectado');
          this.emitDisconnected(state);
          break;

        case 'UNPAIRED':
        case 'UNPAIRED_IDLE':
          this.isConnected = false;
          this.qrCode = null;
          logger.warn('⚠️  WhatsApp desconectado (dispositivo não pareado)');
          this.emitDisconnected(state);
          break;

        default:
          logger.debug(`🔄 Estado: ${state}`);
          this.emitStatus();
      }
    });

    logger.info('✅ Listener onStateChange configurado');
  }

  /**
   * ✅ NOVO: Listener nativo onPresenceChanged
   * Monitora mudanças de presença (online, offline, digitando, gravando áudio)
   */
  private setupPresenceListener(): void {
    if (!this.client) {
      logger.error('Cliente WhatsApp não inicializado');
      return;
    }

    // ✅ NATIVO: onPresenceChanged
    this.client.onPresenceChanged((event: any) => {
      try {
        logger.debug(`👤 Presença mudou: ${event.id} → ${event.state}`);

        // Emitir via WebSocket
        if (this.io) {
          this.io.sockets.emit('whatsapp:presence', {
            contactId: event.id,
            state: event.state,              // 'available', 'unavailable', 'composing', 'recording'
            isOnline: event.isOnline,
            isTyping: event.state === 'composing',
            isRecording: event.state === 'recording',
            lastSeen: event.t ? new Date(event.t * 1000) : null,
          });
        }
      } catch (error) {
        logger.error('Erro ao processar mudança de presença:', error);
      }
    });

    logger.info('✅ Listener onPresenceChanged configurado');
  }

  /**
   * ✅ REFATORADO: Configurar listeners para TODAS as mensagens (enviadas + recebidas)
   * Usa onAnyMessage() nativo ao invés de onMessage() para capturar mensagens enviadas também
   */
  private setupMessageListeners(): void {
    if (!this.client) {
      logger.error('Cliente WhatsApp não inicializado');
      return;
    }

    // ✅ NATIVO: onAnyMessage captura TODAS mensagens (enviadas + recebidas)
    this.client.onAnyMessage(async (message: Message) => {
      try {
        // Filtrar broadcasts e grupos (opcional)
        if (message.from === 'status@broadcast') {
          return;
        }

        const direction = message.fromMe ? '📤 Enviada' : '📩 Recebida';
        const normalizedPhone = message.from.replace('@c.us', '').replace('@g.us', '');

        logger.info(`${direction} de ${normalizedPhone}: ${message.body?.substring(0, 50) || '(mídia)'}...`);

        // ✅ MELHORIA: Processar mensagens recebidas (não enviadas por nós)
        if (!message.fromMe) {
          // Verificar se tem bot ativo
          try {
            const { prisma } = await import('../config/database');

            const botSession = await prisma.whatsAppBotSession.findFirst({
              where: {
                phone: normalizedPhone.replace(/\D/g, ''),
                isActive: true,
                handedOffToHuman: false,
              },
            });

            if (botSession) {
              logger.info(`🤖 Roteando para bot - Sessão ${botSession.id}`);
              const { whatsappBotService } = await import('../modules/whatsapp-bot/whatsapp-bot.service');
              await whatsappBotService.processUserMessage(normalizedPhone.replace(/\D/g, ''), message.body);
              return;
            }
          } catch (error) {
            logger.error('Erro ao verificar bot:', error);
          }
        }

        // ✅ STATELESS: Emitir WebSocket para TODAS mensagens (enviadas + recebidas)
        if (this.io) {
          this.io.sockets.emit('message:new', {
            id: message.id,
            from: message.from,
            to: message.to,
            phone: normalizedPhone,
            body: message.body || '',
            type: message.type,
            timestamp: new Date(message.timestamp * 1000),
            fromMe: message.fromMe || false,
            ack: message.ack,
            status: this.mapAckToStatus(message.ack),
          });

          logger.debug(`📡 WebSocket: message:new (${direction}) - ${normalizedPhone}`);
        }

      } catch (error: any) {
        logger.error('Erro ao processar mensagem:', error);
      }
    });

    // ✅ NOVO: Listener para mensagens deletadas (revoked)
    this.client.onRevokedMessage((data: any) => {
      try {
        logger.info(`🗑️ Mensagem deletada: ${data.id}`);

        if (this.io) {
          this.io.sockets.emit('message:revoked', {
            messageId: data.id,
            from: data.from,
            to: data.to,
            refId: data.refId,
          });
        }
      } catch (error) {
        logger.error('Erro ao processar mensagem deletada:', error);
      }
    });

    // ✅ NOVO: Listener para reações
    this.client.onReactionMessage((reaction: any) => {
      try {
        logger.info(`👍 Reação: ${reaction.reactionText} na mensagem ${reaction.msgId}`);

        if (this.io) {
          this.io.sockets.emit('whatsapp:reaction', {
            messageId: reaction.msgId,
            emoji: reaction.reactionText,
            timestamp: new Date(reaction.timestamp * 1000),
            read: reaction.read,
          });
        }
      } catch (error) {
        logger.error('Erro ao processar reação:', error);
      }
    });

    // ✅ NOVO: Listener para edições de mensagens
    this.client.onMessageEdit?.((chatId: any, msgId: string, newMessage: Message) => {
      try {
        logger.info(`✏️ Mensagem editada: ${msgId}`);

        if (this.io) {
          this.io.sockets.emit('message:edited', {
            chatId: typeof chatId === 'string' ? chatId : chatId._serialized,
            messageId: msgId,
            newContent: newMessage.body,
            timestamp: new Date(newMessage.timestamp * 1000),
          });
        }
      } catch (error) {
        logger.error('Erro ao processar edição de mensagem:', error);
      }
    });

    logger.info('✅ Listeners nativos configurados (onAnyMessage, onRevokedMessage, onReactionMessage, onMessageEdit)');
  }

  /**
   * ⭐ FASE 1: Configurar Phone Watchdog - Monitoramento ativo de conexão
   * Verifica status do telefone a cada 30 segundos
   */
  private setupPhoneWatchdog(): void {
    if (!this.client) {
      logger.error('❌ Cliente WhatsApp não inicializado para Phone Watchdog');
      return;
    }

    try {
      // Iniciar monitoramento a cada 30 segundos
      this.client.startPhoneWatchdog(30000);
      logger.info('✅ Phone Watchdog ativado (verificação a cada 30s)');
    } catch (error) {
      logger.error('❌ Erro ao iniciar Phone Watchdog:', error);
    }
  }

  /**
   * Configurar listeners para ACKs (confirmações de leitura/entrega)
   */
  private setupAckListeners(): void {
    if (!this.client) {
      logger.error('Cliente WhatsApp não inicializado');
      return;
    }

    // Listener para mudanças de status (ACK)
    this.client.onAck(async (ack: any) => {
      try {
        // Normalizar messageId (pode vir como objeto ou string)
        let messageId: string;
        if (typeof ack.id === 'string') {
          messageId = ack.id;
        } else if (ack.id?._serialized) {
          messageId = ack.id._serialized;
        } else if (typeof ack.id === 'object') {
          messageId = JSON.stringify(ack.id);
        } else {
          logger.warn('⚠️  ACK com ID inválido:', ack);
          return;
        }

        const ackCode = ack.ack;

        // ✅ MAPEAMENTO COMPLETO DE ACK (padrão WhatsApp Web)
        const statusName =
          ackCode === -1 ? 'ERROR' :     // Erro no envio
          ackCode === 0 ? 'PENDING' :    // Pendente (relógio)
          ackCode === 1 ? 'SENT' :       // Enviado (1 check cinza)
          ackCode === 2 ? 'SENT' :       // Server recebeu (1 check cinza)
          ackCode === 3 ? 'DELIVERED' :  // Entregue (2 checks cinza)
          ackCode === 4 ? 'READ' :       // Lido (2 checks azuis)
          ackCode === 5 ? 'PLAYED' :     // Reproduzido (áudio/vídeo)
          'UNKNOWN';

        logger.info(`📨 ACK recebido: ${messageId.substring(0, 20)}... -> ${statusName} (ACK ${ackCode})`);

        // ✅ STATELESS: Emitir WebSocket diretamente (não persiste no banco)
        if (this.io) {
          this.io.sockets.emit('message:status', {
            messageIds: [messageId],
            status: statusName,
            ackCode,
          });
          logger.debug(`📡 WebSocket emitido: message:status -> ${messageId.substring(0, 20)}... (${statusName})`);
        }

        // ✅ HÍBRIDO: Atualizar status no banco (para mensagens salvas na estratégia híbrida)
        await whatsappChatService.updateMessageStatus(messageId, ackCode);

      } catch (error) {
        logger.error('Erro ao processar ACK:', error);
      }
    });

    // ⭐ FASE 1: Polling com controle de concorrência e timeout
    // Como o onAck pode não disparar para DELIVERED/READ, vamos fazer polling
    this.pollingInterval = setInterval(async () => {
      if (this.isPolling) {
        logger.warn('⚠️  Polling anterior ainda em execução, pulando iteração...');
        return;
      }

      this.isPolling = true;

      try {
        // Timeout de 8 segundos para evitar travamentos
        await Promise.race([
          this.checkRecentMessagesStatus(),
          new Promise<void>((_, reject) =>
            setTimeout(() => reject(new Error('Polling timeout')), 8000)
          )
        ]);
      } catch (error: any) {
        if (error.message === 'Polling timeout') {
          logger.error('⏱️  Polling timeout - operação demorou mais de 8s');
        } else {
          logger.error('❌ Erro no polling de status:', error);
        }
      } finally {
        this.isPolling = false;
      }
    }, 10000); // Verificar a cada 10 segundos

    logger.info('✅ Listeners de ACK configurados + polling de status ativado (com timeout)');
  }

  /**
   * ⚠️ DEPRECATED - ARQUITETURA STATELESS 2025
   * Polling desabilitado pois não há mais tabela whatsAppMessage
   */
  private async checkRecentMessagesStatus(): Promise<void> {
    // Polling desabilitado - arquitetura stateless não persiste mensagens
    return;
  }

  /**
   * Obter QR Code em base64
   * @returns QR Code em formato data:image/png;base64 ou null
   */
  getQRCode(): string | null {
    return this.qrCode;
  }

  /**
   * Verificar se está conectado
   * @returns true se conectado
   */
  isWhatsAppConnected(): boolean {
    return this.isConnected;
  }

  /**
   * Obter informações da conta conectada
   */
  async getAccountInfo(): Promise<any> {
    if (!this.client || !this.isConnected) {
      throw new Error('WhatsApp não conectado');
    }

    try {
      // Tentar obter informações do dispositivo
      const hostDevice: any = await this.client.getHostDevice().catch(() => null);

      // Se getHostDevice falhar, tentar alternativas
      if (hostDevice) {
        return {
          phone: hostDevice?.id?.user || hostDevice?.wid?.user || 'Desconhecido',
          name: hostDevice?.pushname || 'WhatsApp Business',
          platform: 'WPPConnect',
          connected: true,
        };
      }

      // Fallback: retornar informações básicas
      return {
        phone: 'Conectado',
        name: 'WhatsApp Business',
        platform: 'WPPConnect',
        connected: true,
      };
    } catch (error) {
      logger.error('Erro ao obter informações da conta:', error);

      // Retornar informações mínimas mesmo em caso de erro
      return {
        phone: 'Conectado',
        name: 'WhatsApp Business',
        platform: 'WPPConnect',
        connected: this.isConnected,
      };
    }
  }

  /**
   * ⭐ FASE 1: Enviar mensagem de texto com validações e retry
   * @param to Número do destinatário (com código do país, ex: 5511999999999)
   * @param message Mensagem a ser enviada
   */
  async sendTextMessage(to: string, message: string): Promise<void> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!message || typeof message !== 'string' || message.trim() === '') {
      throw new Error('Mensagem vazia não pode ser enviada');
    }

    const timestamp = new Date().toISOString();
    const toMasked = to.substring(0, 8) + '***';

    // Log estruturado
    logger.info('📨 Enviando mensagem de texto', {
      to: toMasked,
      messageLength: message.length,
      timestamp,
      sessionActive: this.isConnected,
      clientInitialized: !!this.client,
    });

    // Usar retry logic
    await this.sendWithRetry(async () => {
      try {
        // Formatar número para o padrão do WhatsApp (com validação)
        const formattedNumber = this.formatPhoneNumber(to);

        // Enviar mensagem via WPPConnect
        const result = await this.client!.sendText(formattedNumber, message);

        logger.info(`✅ Mensagem enviada com sucesso`, {
          to: toMasked,
          messageId: result.id?._serialized || result.id,
          timestamp: new Date().toISOString(),
        });

        // ✅ CRÍTICO: Extrair número limpo do ID retornado pelo WhatsApp para garantir consistência
        // O WhatsApp retorna IDs no formato: true_5511999999999@c.us_MESSAGEID ou 5511999999999@c.us
        let phoneFromResult = formattedNumber.replace('@c.us', '');
        if (result.id?._serialized) {
          const parts = result.id._serialized.split('@')[0].split('_');
          // Pegar a última parte que contém o número (ignora 'true' e outros prefixos)
          phoneFromResult = parts[parts.length - 1];
        }

        // Salvar mensagem enviada no banco (estratégia híbrida)
        await whatsappChatService.saveOutgoingMessage({
          to: phoneFromResult, // ✅ Usar número do WhatsApp, não o número original
          content: message,
          whatsappMessageId: result.id || `${Date.now()}_${to}`,
          timestamp: new Date(),
        });

      } catch (error: any) {
        logger.error('❌ Erro ao enviar mensagem', {
          error: error.message,
          stack: error.stack,
          to: toMasked,
          attemptedAt: new Date().toISOString(),
          wasConnected: this.isConnected,
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 1: Enviar imagem com validações e retry
   * @param to Número de destino
   * @param imageUrl URL da imagem
   * @param caption Legenda opcional
   * @returns ID da mensagem no WhatsApp
   */
  async sendImage(to: string, imageUrl: string, caption?: string): Promise<string | undefined> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!imageUrl || typeof imageUrl !== 'string' || imageUrl.trim() === '') {
      throw new Error('URL da imagem inválida');
    }

    const toMasked = to.substring(0, 8) + '***';

    logger.info('🖼️ Enviando imagem', {
      to: toMasked,
      imageUrl: imageUrl.substring(0, 50) + '...',
      hasCaption: !!caption,
      timestamp: new Date().toISOString(),
    });

    return await this.sendWithRetry(async () => {
      try {
        const formattedNumber = this.formatPhoneNumber(to);

        // Enviar imagem via WPPConnect
        const result = await this.client!.sendImage(
          formattedNumber,
          imageUrl,
          'image',
          caption || ''
        );

        logger.info(`✅ Imagem enviada com sucesso`, {
          to: toMasked,
          messageId: result.id,
        });

        return result.id;

      } catch (error: any) {
        logger.error('❌ Erro ao enviar imagem', {
          error: error.message,
          to: toMasked,
          imageUrl: imageUrl.substring(0, 50) + '...',
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 1: Enviar vídeo com validações e retry
   * @param to Número de destino
   * @param videoUrl URL do vídeo
   * @param caption Legenda opcional
   * @returns ID da mensagem no WhatsApp
   */
  async sendVideo(to: string, videoUrl: string, caption?: string): Promise<string | undefined> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!videoUrl || typeof videoUrl !== 'string' || videoUrl.trim() === '') {
      throw new Error('URL do vídeo inválida');
    }

    const toMasked = to.substring(0, 8) + '***';

    logger.info('🎥 Enviando vídeo', {
      to: toMasked,
      videoUrl: videoUrl.substring(0, 50) + '...',
      hasCaption: !!caption,
      timestamp: new Date().toISOString(),
    });

    return await this.sendWithRetry(async () => {
      try {
        const formattedNumber = this.formatPhoneNumber(to);

        // Enviar vídeo via WPPConnect
        const result = await this.client!.sendVideoAsGif(
          formattedNumber,
          videoUrl,
          'video.mp4',
          caption || ''
        );

        logger.info(`✅ Vídeo enviado com sucesso`, {
          to: toMasked,
          messageId: result.id,
        });

        return result.id;

      } catch (error: any) {
        logger.error('❌ Erro ao enviar vídeo', {
          error: error.message,
          to: toMasked,
          videoUrl: videoUrl.substring(0, 50) + '...',
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 2: Enviar áudio (Push-to-Talk)
   * @param to Número de destino
   * @param audioPath Caminho ou URL do arquivo de áudio
   * @param caption Legenda opcional
   * @returns ID da mensagem no WhatsApp
   */
  async sendAudio(to: string, audioPath: string, caption?: string): Promise<string | undefined> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!audioPath || typeof audioPath !== 'string' || audioPath.trim() === '') {
      throw new Error('Caminho do áudio inválido');
    }

    const toMasked = to.substring(0, 8) + '***';

    logger.info('🎤 Enviando áudio (PTT)', {
      to: toMasked,
      audioPath: audioPath.substring(0, 50) + '...',
      hasCaption: !!caption,
      timestamp: new Date().toISOString(),
    });

    return await this.sendWithRetry(async () => {
      try {
        const formattedNumber = this.formatPhoneNumber(to);

        // Enviar áudio como PTT (Push-to-Talk) via WPPConnect
        const result = await this.client!.sendPtt(formattedNumber, audioPath);

        logger.info(`✅ Áudio enviado com sucesso`, {
          to: toMasked,
          messageId: result.id,
        });

        return result.id;

      } catch (error: any) {
        logger.error('❌ Erro ao enviar áudio', {
          error: error.message,
          to: toMasked,
          audioPath: audioPath.substring(0, 50) + '...',
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 2: Enviar reação a uma mensagem
   * @param messageId ID da mensagem (serialized)
   * @param emoji Emoji da reação (ou false para remover)
   * @returns Resultado da operação
   */
  async sendReaction(messageId: string, emoji: string | false): Promise<{ sendMsgResult: string }> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!messageId || typeof messageId !== 'string' || messageId.trim() === '') {
      throw new Error('ID da mensagem inválido');
    }

    const action = emoji === false ? 'remover' : 'enviar';
    const emojiDisplay = emoji === false ? '(removendo)' : emoji;

    logger.info(`${emoji === false ? '🚫' : '👍'} ${action === 'remover' ? 'Removendo' : 'Enviando'} reação`, {
      messageId: messageId.substring(0, 20) + '...',
      emoji: emojiDisplay,
      timestamp: new Date().toISOString(),
    });

    return await this.sendWithRetry(async () => {
      try {
        // Enviar reação via WPPConnect
        const result = await this.client!.sendReactionToMessage(messageId, emoji);

        logger.info(`✅ Reação ${action === 'remover' ? 'removida' : 'enviada'} com sucesso`, {
          messageId: messageId.substring(0, 20) + '...',
          emoji: emojiDisplay,
        });

        return result;

      } catch (error: any) {
        logger.error(`❌ Erro ao ${action} reação`, {
          error: error.message,
          messageId: messageId.substring(0, 20) + '...',
          emoji: emojiDisplay,
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 2: Marcar mensagem como lida
   * @param chatId ID do chat (ex: 5511999999999@c.us)
   * @returns void
   */
  async markAsRead(chatId: string): Promise<void> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!chatId || typeof chatId !== 'string' || chatId.trim() === '') {
      throw new Error('ID do chat inválido');
    }

    logger.info('👁️ Marcando chat como lido', {
      chatId: chatId.substring(0, 20) + '...',
      timestamp: new Date().toISOString(),
    });

    await this.sendWithRetry(async () => {
      try {
        // Marcar como lido via WPPConnect
        await this.client!.sendSeen(chatId);

        logger.info(`✅ Chat marcado como lido`, {
          chatId: chatId.substring(0, 20) + '...',
        });

      } catch (error: any) {
        logger.error('❌ Erro ao marcar como lido', {
          error: error.message,
          chatId: chatId.substring(0, 20) + '...',
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 2: Marcar chat como não lido
   * @param chatId ID do chat (ex: 5511999999999@c.us)
   * @returns void
   */
  async markAsUnread(chatId: string): Promise<void> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!chatId || typeof chatId !== 'string' || chatId.trim() === '') {
      throw new Error('ID do chat inválido');
    }

    logger.info('👀 Marcando chat como não lido', {
      chatId: chatId.substring(0, 20) + '...',
      timestamp: new Date().toISOString(),
    });

    await this.sendWithRetry(async () => {
      try {
        // Marcar como não lido via WPPConnect
        await this.client!.markUnseenMessage(chatId);

        logger.info(`✅ Chat marcado como não lido`, {
          chatId: chatId.substring(0, 20) + '...',
        });

      } catch (error: any) {
        logger.error('❌ Erro ao marcar como não lido', {
          error: error.message,
          chatId: chatId.substring(0, 20) + '...',
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 2: Deletar mensagem
   * @param chatId ID do chat
   * @param messageId ID da mensagem ou array de IDs
   * @param forEveryone Se true, deleta para todos; se false, deleta apenas localmente
   * @returns void
   */
  async deleteMessage(
    chatId: string,
    messageId: string | string[],
    forEveryone: boolean = false
  ): Promise<void> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!chatId || typeof chatId !== 'string' || chatId.trim() === '') {
      throw new Error('ID do chat inválido');
    }

    if (!messageId) {
      throw new Error('ID da mensagem inválido');
    }

    const messageIds = Array.isArray(messageId) ? messageId : [messageId];
    const scope = forEveryone ? 'para todos' : 'localmente';

    logger.info(`🗑️ Deletando mensagem ${scope}`, {
      chatId: chatId.substring(0, 20) + '...',
      messageCount: messageIds.length,
      forEveryone,
      timestamp: new Date().toISOString(),
    });

    await this.sendWithRetry(async () => {
      try {
        // Deletar mensagem via WPPConnect
        await this.client!.deleteMessage(chatId, messageIds, forEveryone);

        logger.info(`✅ Mensagem deletada ${scope}`, {
          chatId: chatId.substring(0, 20) + '...',
          messageCount: messageIds.length,
        });

      } catch (error: any) {
        logger.error(`❌ Erro ao deletar mensagem ${scope}`, {
          error: error.message,
          chatId: chatId.substring(0, 20) + '...',
          messageCount: messageIds.length,
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 3: Enviar arquivo genérico (documento, PDF, etc.)
   * @param to Número de destino
   * @param filePath Caminho ou URL do arquivo
   * @param filename Nome do arquivo a ser exibido
   * @param caption Legenda opcional
   * @returns ID da mensagem no WhatsApp
   */
  async sendFile(
    to: string,
    filePath: string,
    filename?: string,
    caption?: string
  ): Promise<string | undefined> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!filePath || typeof filePath !== 'string' || filePath.trim() === '') {
      throw new Error('Caminho do arquivo inválido');
    }

    const toMasked = to.substring(0, 8) + '***';
    const displayFilename = filename || 'documento';

    logger.info('📎 Enviando arquivo', {
      to: toMasked,
      filePath: filePath.substring(0, 50) + '...',
      filename: displayFilename,
      hasCaption: !!caption,
      timestamp: new Date().toISOString(),
    });

    return await this.sendWithRetry(async () => {
      try {
        const formattedNumber = this.formatPhoneNumber(to);

        // Enviar arquivo via WPPConnect
        const result = await this.client!.sendFile(
          formattedNumber,
          filePath,
          displayFilename,
          caption || ''
        );

        logger.info(`✅ Arquivo enviado com sucesso`, {
          to: toMasked,
          filename: displayFilename,
          messageId: result.id,
        });

        return result.id;

      } catch (error: any) {
        logger.error('❌ Erro ao enviar arquivo', {
          error: error.message,
          to: toMasked,
          filePath: filePath.substring(0, 50) + '...',
          filename: displayFilename,
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 3: Enviar localização
   * @param to Número de destino
   * @param latitude Latitude
   * @param longitude Longitude
   * @param name Nome do local (opcional)
   * @returns ID da mensagem no WhatsApp
   */
  async sendLocation(
    to: string,
    latitude: number,
    longitude: number,
    name?: string
  ): Promise<string | undefined> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (typeof latitude !== 'number' || typeof longitude !== 'number') {
      throw new Error('Latitude e longitude devem ser números');
    }

    if (latitude < -90 || latitude > 90) {
      throw new Error('Latitude inválida. Deve estar entre -90 e 90');
    }

    if (longitude < -180 || longitude > 180) {
      throw new Error('Longitude inválida. Deve estar entre -180 e 180');
    }

    const toMasked = to.substring(0, 8) + '***';
    const locationName = name || 'Localização';

    logger.info('📍 Enviando localização', {
      to: toMasked,
      latitude,
      longitude,
      name: locationName,
      timestamp: new Date().toISOString(),
    });

    return await this.sendWithRetry(async () => {
      try {
        const formattedNumber = this.formatPhoneNumber(to);

        // Enviar localização via WPPConnect
        const result = await this.client!.sendLocation(
          formattedNumber,
          latitude,
          longitude,
          locationName
        );

        logger.info(`✅ Localização enviada com sucesso`, {
          to: toMasked,
          latitude,
          longitude,
          messageId: result.id,
        });

        return result.id;

      } catch (error: any) {
        logger.error('❌ Erro ao enviar localização', {
          error: error.message,
          to: toMasked,
          latitude,
          longitude,
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 3: Enviar contato vCard
   * @param to Número de destino
   * @param contactId ID do contato no formato WhatsApp (ex: 5511999999999@c.us)
   * @param name Nome do contato
   * @returns ID da mensagem no WhatsApp
   */
  async sendContactVcard(
    to: string,
    contactId: string,
    name?: string
  ): Promise<string | undefined> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!contactId || typeof contactId !== 'string' || contactId.trim() === '') {
      throw new Error('ID do contato inválido');
    }

    const toMasked = to.substring(0, 8) + '***';
    const contactName = name || 'Contato';

    logger.info('👤 Enviando contato vCard', {
      to: toMasked,
      contactId: contactId.substring(0, 15) + '...',
      name: contactName,
      timestamp: new Date().toISOString(),
    });

    return await this.sendWithRetry(async () => {
      try {
        const formattedNumber = this.formatPhoneNumber(to);

        // Enviar vCard via WPPConnect
        const result = await this.client!.sendContactVcard(
          formattedNumber,
          contactId,
          contactName
        );

        logger.info(`✅ Contato vCard enviado com sucesso`, {
          to: toMasked,
          contactName,
          messageId: result.id,
        });

        return result.id;

      } catch (error: any) {
        logger.error('❌ Erro ao enviar contato vCard', {
          error: error.message,
          to: toMasked,
          contactId: contactId.substring(0, 15) + '...',
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 3: Estrelar mensagem
   * @param messageId ID da mensagem
   * @param star Se true, estrela; se false, remove estrela
   * @returns void
   */
  async starMessage(messageId: string, star: boolean = true): Promise<void> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!messageId || typeof messageId !== 'string' || messageId.trim() === '') {
      throw new Error('ID da mensagem inválido');
    }

    const action = star ? 'estrelando' : 'removendo estrela';

    logger.info(`⭐ ${star ? 'Estrelando' : 'Removendo estrela de'} mensagem`, {
      messageId: messageId.substring(0, 20) + '...',
      star,
      timestamp: new Date().toISOString(),
    });

    await this.sendWithRetry(async () => {
      try {
        // Estrelar/desestrelar mensagem via WPPConnect
        await this.client!.starMessage(messageId, star);

        logger.info(`✅ Mensagem ${star ? 'estrelada' : 'não estrelada'} com sucesso`, {
          messageId: messageId.substring(0, 20) + '...',
          star,
        });

      } catch (error: any) {
        logger.error(`❌ Erro ao ${action} mensagem`, {
          error: error.message,
          messageId: messageId.substring(0, 20) + '...',
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 3: Obter mensagens estreladas
   * @returns Array de mensagens estreladas
   */
  async getStarredMessages(): Promise<any[]> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    logger.info('⭐ Buscando mensagens estreladas', {
      timestamp: new Date().toISOString(),
    });

    return await this.sendWithRetry(async () => {
      try {
        // Obter mensagens estreladas via WPPConnect
        const starredMessages = await this.client!.getStarredMessages();

        logger.info(`✅ ${starredMessages.length} mensagens estreladas encontradas`);

        return starredMessages;

      } catch (error: any) {
        logger.error('❌ Erro ao buscar mensagens estreladas', {
          error: error.message,
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 3: Arquivar conversa
   * @param chatId ID do chat
   * @param archive Se true, arquiva; se false, desarquiva
   * @returns void
   */
  async archiveChat(chatId: string, archive: boolean = true): Promise<void> {
    // Validações iniciais
    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado. Reinicie o serviço.');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não conectado. Escaneie o QR Code primeiro.');
    }

    if (!chatId || typeof chatId !== 'string' || chatId.trim() === '') {
      throw new Error('ID do chat inválido');
    }

    const action = archive ? 'arquivando' : 'desarquivando';

    logger.info(`📦 ${archive ? 'Arquivando' : 'Desarquivando'} conversa`, {
      chatId: chatId.substring(0, 20) + '...',
      archive,
      timestamp: new Date().toISOString(),
    });

    await this.sendWithRetry(async () => {
      try {
        // Arquivar/desarquivar chat via WPPConnect
        await this.client!.archiveChat(chatId, archive);

        logger.info(`✅ Conversa ${archive ? 'arquivada' : 'desarquivada'} com sucesso`, {
          chatId: chatId.substring(0, 20) + '...',
          archive,
        });

      } catch (error: any) {
        logger.error(`❌ Erro ao ${action} conversa`, {
          error: error.message,
          chatId: chatId.substring(0, 20) + '...',
        });
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE 1: Retry Logic com Exponential Backoff
   * @param fn Função assíncrona a ser executada
   * @param retries Número de tentativas (padrão: 3)
   * @param delay Delay inicial em ms (padrão: 2000ms)
   * @returns Resultado da função
   */
  private async sendWithRetry<T>(
    fn: () => Promise<T>,
    retries: number = 3,
    delay: number = 2000
  ): Promise<T> {
    let lastError: any;

    for (let i = 0; i < retries; i++) {
      try {
        return await fn();
      } catch (error: any) {
        lastError = error;

        // Não fazer retry em erros permanentes
        const errorMsg = error?.message || '';
        const isPermanentError =
          errorMsg.includes('não conectado') ||
          errorMsg.includes('não inicializado') ||
          errorMsg.includes('inválido');

        if (isPermanentError) {
          logger.error('❌ Erro permanente detectado, abortando retry:', errorMsg);
          throw error;
        }

        if (i < retries - 1) {
          logger.warn(`⚠️  Tentativa ${i + 1}/${retries} falhou. Retrying em ${delay}ms...`, {
            error: errorMsg,
          });
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2; // Exponential backoff
        }
      }
    }

    logger.error(`❌ Todas as ${retries} tentativas falharam`);
    throw lastError;
  }

  // ==========================================
  // FASE C: FUNCIONALIDADES AUSENTES
  // ==========================================

  /**
   * ⭐ FASE C: Download de mídia de uma mensagem
   * @param messageId ID da mensagem
   * @returns Buffer do arquivo
   */
  async downloadMedia(messageId: string): Promise<Buffer> {
    logger.info(`📥 Baixando mídia da mensagem: ${messageId}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      // Baixar mídia usando WPPConnect
      const mediaData = await this.client.decryptFile(messageId);
      logger.info(`✅ Mídia baixada com sucesso: ${messageId}`);
      return Buffer.from(mediaData);
    } catch (error: any) {
      logger.error(`❌ Erro ao baixar mídia: ${messageId}`, error);
      throw new Error(`Erro ao baixar mídia: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE C: Encaminhar mensagem
   * @param messageId ID da mensagem a encaminhar
   * @param to Destinatário(s) - string ou array
   */
  async forwardMessage(messageId: string, to: string | string[]): Promise<void> {
    logger.info(`📨 Encaminhando mensagem ${messageId} para:`, to);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      const recipients = Array.isArray(to) ? to : [to];

      for (const recipient of recipients) {
        const formattedNumber = this.formatPhoneNumber(recipient);
        await this.client.forwardMessages(formattedNumber, [messageId], false);
        logger.info(`✅ Mensagem encaminhada para: ${formattedNumber}`);
      }
    } catch (error: any) {
      logger.error(`❌ Erro ao encaminhar mensagem: ${messageId}`, error);
      throw new Error(`Erro ao encaminhar mensagem: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE C: Fixar/Desafixar chat
   * @param chatId ID do chat
   * @param pin true para fixar, false para desafixar
   */
  async pinChat(chatId: string, pin: boolean = true): Promise<void> {
    logger.info(`📌 ${pin ? 'Fixando' : 'Desfixando'} chat: ${chatId}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      await this.client.pinChat(chatId, pin);
      logger.info(`✅ Chat ${pin ? 'fixado' : 'desfixado'}: ${chatId}`);
    } catch (error: any) {
      logger.error(`❌ Erro ao ${pin ? 'fixar' : 'desfixar'} chat: ${chatId}`, error);
      throw new Error(`Erro ao ${pin ? 'fixar' : 'desfixar'} chat: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE C: Listar todos os contatos
   * @returns Lista de contatos
   */
  async getContacts(): Promise<any[]> {
    logger.info('📇 Listando contatos do WhatsApp');

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      const contacts = await this.client.getAllContacts();
      logger.info(`✅ ${contacts.length} contatos recuperados`);
      return contacts;
    } catch (error: any) {
      logger.error('❌ Erro ao listar contatos:', error);
      throw new Error(`Erro ao listar contatos: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE C: Verificar se número(s) está(ão) no WhatsApp
   * @param phoneNumbers Número ou array de números
   * @returns Array com status de cada número
   */
  async checkNumbersOnWhatsApp(phoneNumbers: string | string[]): Promise<any[]> {
    logger.info('🔍 Verificando números no WhatsApp:', phoneNumbers);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      const numbers = Array.isArray(phoneNumbers) ? phoneNumbers : [phoneNumbers];
      const results = [];

      for (const phoneNumber of numbers) {
        try {
          const formatted = this.formatPhoneNumber(phoneNumber);
          const numberExists = await this.client.checkNumberStatus(formatted);

          results.push({
            phoneNumber,
            formatted,
            exists: numberExists.numberExists || false,
            status: numberExists,
          });

          logger.info(`✅ ${phoneNumber} → ${numberExists.numberExists ? 'EXISTE' : 'NÃO EXISTE'}`);
        } catch (error: any) {
          results.push({
            phoneNumber,
            exists: false,
            error: error.message,
          });
          logger.warn(`⚠️  Erro ao verificar ${phoneNumber}: ${error.message}`);
        }
      }

      return results;
    } catch (error: any) {
      logger.error('❌ Erro ao verificar números:', error);
      throw new Error(`Erro ao verificar números: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE C: Criar grupo
   * @param name Nome do grupo
   * @param participants Array de números dos participantes
   * @returns Informações do grupo criado
   */
  async createGroup(name: string, participants: string[]): Promise<any> {
    logger.info(`👥 Criando grupo: ${name} com ${participants.length} participantes`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    if (!name || name.trim() === '') {
      throw new Error('Nome do grupo não pode ser vazio');
    }

    if (!participants || participants.length === 0) {
      throw new Error('É necessário pelo menos 1 participante');
    }

    try {
      // Formatar números dos participantes
      const formattedParticipants = participants.map(p => this.formatPhoneNumber(p));

      // Criar grupo
      const group = await this.client.createGroup(name, formattedParticipants);

      logger.info(`✅ Grupo criado: ${name} (ID: ${group.gid})`);
      return group;
    } catch (error: any) {
      logger.error(`❌ Erro ao criar grupo: ${name}`, error);
      throw new Error(`Erro ao criar grupo: ${error.message}`);
    }
  }

  // ==========================================
  // FASE D: FUNCIONALIDADES AVANÇADAS
  // ==========================================

  /**
   * ⭐ FASE D: Enviar mensagem de lista interativa
   * @param to Número do destinatário
   * @param title Título da lista
   * @param description Descrição
   * @param buttonText Texto do botão
   * @param sections Seções da lista com opções
   */
  async sendList(
    to: string,
    title: string,
    description: string,
    buttonText: string,
    sections: Array<{ title: string; rows: Array<{ title: string; description?: string; rowId: string }> }>
  ): Promise<string | undefined> {
    logger.info(`📋 Enviando lista interativa para: ${to}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    const formattedNumber = this.formatPhoneNumber(to);

    return this.sendWithRetry(async () => {
      try {
        const result = await this.client!.sendListMessage(formattedNumber, {
          buttonText,
          description,
          title,
          sections,
        });

        logger.info(`✅ Lista enviada para ${formattedNumber}`);
        return result.id;
      } catch (error: any) {
        logger.error(`❌ Erro ao enviar lista para ${formattedNumber}:`, error);
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE D: Enviar mensagem com botões de resposta
   * @param to Número do destinatário
   * @param message Texto da mensagem
   * @param buttons Array de botões (máx 3)
   */
  async sendButtons(
    to: string,
    message: string,
    buttons: Array<{ buttonText: string; buttonId: string }>
  ): Promise<string | undefined> {
    logger.info(`🔘 Enviando mensagem com botões para: ${to}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    if (buttons.length > 3) {
      throw new Error('WhatsApp permite no máximo 3 botões');
    }

    const formattedNumber = this.formatPhoneNumber(to);

    return this.sendWithRetry(async () => {
      try {
        const result = await this.client!.sendButtons(formattedNumber, message, buttons);

        logger.info(`✅ Mensagem com botões enviada para ${formattedNumber}`);
        return result.id;
      } catch (error: any) {
        logger.error(`❌ Erro ao enviar botões para ${formattedNumber}:`, error);
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE D: Enviar enquete (poll)
   * @param to Número do destinatário
   * @param name Título da enquete
   * @param options Array de opções (2-12 opções)
   */
  async sendPoll(
    to: string,
    name: string,
    options: string[]
  ): Promise<string | undefined> {
    logger.info(`📊 Enviando enquete para: ${to}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    if (options.length < 2 || options.length > 12) {
      throw new Error('Enquetes devem ter entre 2 e 12 opções');
    }

    const formattedNumber = this.formatPhoneNumber(to);

    return this.sendWithRetry(async () => {
      try {
        const result = await this.client!.sendPollMessage(formattedNumber, name, options);

        logger.info(`✅ Enquete enviada para ${formattedNumber}`);
        return result.id;
      } catch (error: any) {
        logger.error(`❌ Erro ao enviar enquete para ${formattedNumber}:`, error);
        throw error;
      }
    });
  }

  /**
   * ⭐ FASE D: Adicionar participante ao grupo
   * @param groupId ID do grupo
   * @param participantNumber Número do participante
   */
  async addParticipantToGroup(groupId: string, participantNumber: string): Promise<void> {
    logger.info(`👤 Adicionando participante ${participantNumber} ao grupo ${groupId}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      const formattedNumber = this.formatPhoneNumber(participantNumber);
      await this.client.addParticipant(groupId, [formattedNumber]);

      logger.info(`✅ Participante adicionado: ${formattedNumber}`);
    } catch (error: any) {
      logger.error(`❌ Erro ao adicionar participante:`, error);
      throw new Error(`Erro ao adicionar participante: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE D: Remover participante do grupo
   * @param groupId ID do grupo
   * @param participantNumber Número do participante
   */
  async removeParticipantFromGroup(groupId: string, participantNumber: string): Promise<void> {
    logger.info(`👤 Removendo participante ${participantNumber} do grupo ${groupId}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      const formattedNumber = this.formatPhoneNumber(participantNumber);
      await this.client.removeParticipant(groupId, [formattedNumber]);

      logger.info(`✅ Participante removido: ${formattedNumber}`);
    } catch (error: any) {
      logger.error(`❌ Erro ao remover participante:`, error);
      throw new Error(`Erro ao remover participante: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE D: Alterar descrição do grupo
   * @param groupId ID do grupo
   * @param description Nova descrição
   */
  async setGroupDescription(groupId: string, description: string): Promise<void> {
    logger.info(`📝 Alterando descrição do grupo ${groupId}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      await this.client.setGroupDescription(groupId, description);
      logger.info(`✅ Descrição do grupo atualizada`);
    } catch (error: any) {
      logger.error(`❌ Erro ao alterar descrição:`, error);
      throw new Error(`Erro ao alterar descrição: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE D: Alterar assunto/nome do grupo
   * @param groupId ID do grupo
   * @param subject Novo nome
   */
  async setGroupSubject(groupId: string, subject: string): Promise<void> {
    logger.info(`📝 Alterando nome do grupo ${groupId} para: ${subject}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      await this.client.setGroupSubject(groupId, subject);
      logger.info(`✅ Nome do grupo atualizado`);
    } catch (error: any) {
      logger.error(`❌ Erro ao alterar nome:`, error);
      throw new Error(`Erro ao alterar nome: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE D: Promover participante a admin
   * @param groupId ID do grupo
   * @param participantNumber Número do participante
   */
  async promoteParticipantToAdmin(groupId: string, participantNumber: string): Promise<void> {
    logger.info(`👑 Promovendo ${participantNumber} a admin no grupo ${groupId}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      const formattedNumber = this.formatPhoneNumber(participantNumber);
      await this.client.promoteParticipant(groupId, [formattedNumber]);

      logger.info(`✅ Participante promovido a admin`);
    } catch (error: any) {
      logger.error(`❌ Erro ao promover participante:`, error);
      throw new Error(`Erro ao promover participante: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE D: Remover admin de participante
   * @param groupId ID do grupo
   * @param participantNumber Número do participante
   */
  async demoteParticipantFromAdmin(groupId: string, participantNumber: string): Promise<void> {
    logger.info(`👤 Removendo admin de ${participantNumber} no grupo ${groupId}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      const formattedNumber = this.formatPhoneNumber(participantNumber);
      await this.client.demoteParticipant(groupId, [formattedNumber]);

      logger.info(`✅ Admin removido do participante`);
    } catch (error: any) {
      logger.error(`❌ Erro ao remover admin:`, error);
      throw new Error(`Erro ao remover admin: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE D: Listar participantes do grupo
   * @param groupId ID do grupo
   */
  async getGroupParticipants(groupId: string): Promise<any[]> {
    logger.info(`👥 Listando participantes do grupo ${groupId}`);

    if (!this.client) {
      throw new Error('Cliente WhatsApp não inicializado');
    }

    if (!this.isConnected) {
      throw new Error('WhatsApp não está conectado');
    }

    try {
      const metadata = await this.client.getGroupMetadata(groupId);
      logger.info(`✅ ${metadata.participants.length} participantes recuperados`);
      return metadata.participants;
    } catch (error: any) {
      logger.error(`❌ Erro ao listar participantes:`, error);
      throw new Error(`Erro ao listar participantes: ${error.message}`);
    }
  }

  /**
   * ⭐ FASE 1: Formatar e validar número de telefone
   * @param phoneNumber Número de telefone
   * @returns Número formatado (ex: 5511999999999@c.us)
   * @throws Error se número inválido
   */
  private formatPhoneNumber(phoneNumber: string): string {
    // Validar entrada não vazia
    if (!phoneNumber || typeof phoneNumber !== 'string' || phoneNumber.trim() === '') {
      throw new Error('Número de telefone vazio ou inválido');
    }

    // Remover todos os caracteres não numéricos
    let cleaned = phoneNumber.replace(/\D/g, '');

    // Validações de comprimento
    if (cleaned.length < 10) {
      throw new Error(`Número muito curto: ${phoneNumber}. Mínimo 10 dígitos.`);
    }

    if (cleaned.length > 15) {
      throw new Error(`Número muito longo: ${phoneNumber}. Máximo 15 dígitos.`);
    }

    // Adicionar código do país se não tiver (Brasil = 55)
    if (cleaned.length === 10 || cleaned.length === 11) {
      cleaned = '55' + cleaned;
    }

    // Formato WhatsApp: número@c.us
    const formatted = `${cleaned}@c.us`;

    logger.debug(`📞 Número formatado: ${phoneNumber} -> ${formatted}`);
    return formatted;
  }

  /**
   * Obter o cliente WPPConnect (usado pelo WhatsAppChatService)
   */
  getClient(): Whatsapp | null {
    return this.client;
  }

  /**
   * ⭐ FASE 1: Desconectar WhatsApp com cleanup completo
   * Após desconectar, reinicializa automaticamente para gerar novo QR code
   */
  async disconnect(): Promise<void> {
    // Parar polling
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
      logger.info('⏹️  Polling de status interrompido');
    }

    // Parar Phone Watchdog
    if (this.client) {
      try {
        this.client.stopPhoneWatchdog?.();
        logger.info('⏹️  Phone Watchdog interrompido');
      } catch (error) {
        logger.warn('⚠️  Erro ao parar Phone Watchdog:', error);
      }
    }

    // Desconectar cliente
    if (this.client) {
      try {
        await this.client.close();
        logger.info('👋 WhatsApp desconectado');
        this.isConnected = false;
        this.qrCode = null;
        this.client = null;
      } catch (error) {
        logger.error('Erro ao desconectar WhatsApp:', error);
      }
    }

    // Aguardar 2 segundos antes de reinicializar
    logger.info('🔄 Gerando novo QR Code em 2 segundos...');
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Reinicializar para gerar novo QR code
    this.isInitializing = false;
    await this.initialize();
  }

  // ============================================================================
  // 👥 GRUPOS - 20 FUNCIONALIDADES NATIVAS
  // ============================================================================

  /**
   * Criar novo grupo
   */
  async createGroup(groupName: string, participants: string[]): Promise<any> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      const result = await this.client.createGroup(groupName, participants);
      logger.info(`✅ Grupo criado: ${groupName} com ${participants.length} participantes`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao criar grupo:', error);
      throw error;
    }
  }

  /**
   * Sair de um grupo
   */
  async leaveGroup(groupId: string): Promise<void> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      await this.client.leaveGroup(groupId);
      logger.info(`✅ Saiu do grupo: ${groupId}`);
    } catch (error: any) {
      logger.error('Erro ao sair do grupo:', error);
      throw error;
    }
  }

  /**
   * Obter IDs dos membros do grupo
   */
  async getGroupMembersIds(groupId: string): Promise<any[]> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      return await this.client.getGroupMembersIds(groupId);
    } catch (error: any) {
      logger.error('Erro ao obter IDs dos membros:', error);
      throw error;
    }
  }

  /**
   * Obter membros do grupo como objetos Contact
   */
  async getGroupMembers(groupId: string): Promise<any[]> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      return await this.client.getGroupMembers(groupId);
    } catch (error: any) {
      logger.error('Erro ao obter membros do grupo:', error);
      throw error;
    }
  }

  /**
   * Obter link de convite do grupo
   */
  async getGroupInviteLink(groupId: string): Promise<string> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      return await this.client.getGroupInviteLink(groupId);
    } catch (error: any) {
      logger.error('Erro ao obter link do grupo:', error);
      throw error;
    }
  }

  /**
   * Revogar link de convite e gerar novo
   */
  async revokeGroupInviteLink(groupId: string): Promise<string> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      return await this.client.revokeGroupInviteLink(groupId);
    } catch (error: any) {
      logger.error('Erro ao revogar link do grupo:', error);
      throw error;
    }
  }

  /**
   * Obter informações de grupo via link de convite
   */
  async getGroupInfoFromInviteLink(inviteCode: string): Promise<any> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      return await this.client.getGroupInfoFromInviteLink(inviteCode);
    } catch (error: any) {
      logger.error('Erro ao obter info do grupo via link:', error);
      throw error;
    }
  }

  /**
   * Remover participante do grupo
   */
  async removeParticipant(groupId: string, participantId: string | string[]): Promise<void> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      await this.client.removeParticipant(groupId, participantId);
      logger.info(`✅ Participante(s) removido(s) do grupo ${groupId}`);
    } catch (error: any) {
      logger.error('Erro ao remover participante:', error);
      throw error;
    }
  }

  /**
   * Adicionar participante ao grupo
   */
  async addParticipant(groupId: string, participantId: string | string[]): Promise<any> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      const result = await this.client.addParticipant(groupId, participantId);
      logger.info(`✅ Participante(s) adicionado(s) ao grupo ${groupId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao adicionar participante:', error);
      throw error;
    }
  }

  /**
   * Promover participante a admin
   */
  async promoteParticipant(groupId: string, participantId: string | string[]): Promise<boolean> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      const result = await this.client.promoteParticipant(groupId, participantId);
      logger.info(`✅ Participante(s) promovido(s) a admin no grupo ${groupId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao promover participante:', error);
      throw error;
    }
  }

  /**
   * Remover admin de participante
   */
  async demoteParticipant(groupId: string, participantId: string | string[]): Promise<boolean | void> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      const result = await this.client.demoteParticipant(groupId, participantId);
      logger.info(`✅ Participante(s) rebaixado(s) de admin no grupo ${groupId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao rebaixar participante:', error);
      throw error;
    }
  }

  /**
   * Obter admins do grupo
   */
  async getGroupAdmins(groupId: string): Promise<any[]> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      return await this.client.getGroupAdmins(groupId);
    } catch (error: any) {
      logger.error('Erro ao obter admins do grupo:', error);
      throw error;
    }
  }

  /**
   * Entrar em grupo via link de convite
   */
  async joinGroup(inviteCode: string): Promise<any> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      const result = await this.client.joinGroup(inviteCode);
      logger.info(`✅ Entrou no grupo via convite: ${inviteCode}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao entrar no grupo:', error);
      throw error;
    }
  }

  /**
   * Definir descrição do grupo
   */
  async setGroupDescription(groupId: string, description: string): Promise<boolean> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      const result = await this.client.setGroupDescription(groupId, description);
      logger.info(`✅ Descrição do grupo atualizada: ${groupId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao definir descrição do grupo:', error);
      throw error;
    }
  }

  /**
   * Definir nome/assunto do grupo
   */
  async setGroupSubject(groupId: string, title: string): Promise<boolean> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      const result = await this.client.setGroupSubject(groupId, title);
      logger.info(`✅ Nome do grupo atualizado: ${groupId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao definir nome do grupo:', error);
      throw error;
    }
  }

  /**
   * Definir propriedades do grupo (announce, restrict, etc)
   */
  async setGroupProperty(groupId: string, property: any, value: boolean): Promise<boolean> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      const result = await this.client.setGroupProperty(groupId, property, value);
      logger.info(`✅ Propriedade ${property} do grupo ${groupId} = ${value}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao definir propriedade do grupo:', error);
      throw error;
    }
  }

  /**
   * Definir foto do grupo
   */
  async setGroupIcon(groupId: string, pathOrBase64: string): Promise<any> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      const result = await this.client.setGroupIcon(groupId, pathOrBase64);
      logger.info(`✅ Foto do grupo atualizada: ${groupId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao definir foto do grupo:', error);
      throw error;
    }
  }

  /**
   * Remover foto do grupo
   */
  async removeGroupIcon(groupId: string): Promise<boolean> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      const result = await this.client.removeGroupIcon(groupId);
      logger.info(`✅ Foto do grupo removida: ${groupId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao remover foto do grupo:', error);
      throw error;
    }
  }

  /**
   * Obter limite de tamanho do grupo
   */
  async getGroupSizeLimit(): Promise<number> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      return await this.client.getGroupSizeLimit();
    } catch (error: any) {
      logger.error('Erro ao obter limite do grupo:', error);
      throw error;
    }
  }

  /**
   * Obter grupos em comum com um contato
   */
  async getCommonGroups(contactId: string): Promise<any[]> {
    if (!this.client) throw new Error('WhatsApp não conectado');

    try {
      return await this.client.getCommonGroups(contactId);
    } catch (error: any) {
      logger.error('Erro ao obter grupos em comum:', error);
      throw error;
    }
  }

  // ============================================================================
  // 🔗 DELEGAÇÃO PARA FUNCIONALIDADES EXTENDIDAS (77 funções adicionais)
  // ============================================================================

  // ============================================================================
  // ✅ NOVA ARQUITETURA STATELESS (WPPConnect-First)
  // ============================================================================

  /**
   * ✅ REFATORADO: Busca conversas usando listChats() nativo (ao invés de getAllChats deprecated)
   * Enriquece com metadata do PostgreSQL (tags, leadId, etc)
   */
  async getAllConversations(limit: number = 50): Promise<any[]> {
    if (!this.client) {
      throw new Error('WhatsApp não conectado');
    }

    try {
      // ✅ NATIVO: listChats() com opções
      const chats = await this.client.listChats({
        onlyUsers: true,      // ✅ Apenas conversas privadas (não grupos)
        onlyWithUnreadMessage: false,  // Incluir lidas também
        count: limit,         // Limitar quantidade
      });

      logger.info(`📋 ${chats.length} conversas carregadas via listChats()`);

      // 2. Enriquecer com metadata do PostgreSQL
      const { prisma } = await import('../config/database');

      const enrichedChats = await Promise.all(
        chats.map(async (chat: any) => {
          const phone = chat.id._serialized.replace('@c.us', '');

          // Buscar metadata do contato no PostgreSQL
          const contactMetadata = await prisma.whatsAppContact.findUnique({
            where: { phone },
            include: {
              lead: {
                select: {
                  id: true,
                  name: true,
                  email: true,
                  status: true,
                },
              },
            },
          });

          return {
            id: chat.id._serialized,
            phone,
            name: chat.name || contactMetadata?.name || phone,
            profilePicUrl: chat.profilePicThumb?.eurl || contactMetadata?.profilePicUrl || null,
            lastMessageAt: chat.t ? new Date(chat.t * 1000) : null,
            lastMessagePreview: chat.lastMessage?.body || null,
            unreadCount: chat.unreadCount || 0,
            isPinned: chat.pin || false,
            isArchived: chat.archive || false,
            // ✅ NOVO: Informações adicionais do WPPConnect
            isMuted: chat.muteExpiration > 0,
            labels: chat.labels || [],
            // Metadata do CRM
            lead: contactMetadata?.lead || null,
            tags: contactMetadata?.tags || [],
            contact: {
              id: phone,
              phone,
              name: chat.name || contactMetadata?.name || phone,
              profilePicUrl: chat.profilePicThumb?.eurl || contactMetadata?.profilePicUrl || null,
            },
          };
        })
      );

      return enrichedChats;
    } catch (error: any) {
      logger.error('Erro ao buscar conversas do WhatsApp:', error);
      throw error;
    }
  }

  /**
   * ✅ STATELESS: Busca mensagens de uma conversa direto do WhatsApp
   */
  async getChatMessages(phone: string, count: number = 100): Promise<any[]> {
    if (!this.client) {
      throw new Error('WhatsApp não conectado');
    }

    try {
      // Formatar chat ID
      const cleanPhone = phone.replace(/\D/g, '');
      const chatId = cleanPhone.includes('@c.us') ? cleanPhone : `${cleanPhone}@c.us`;

      // Buscar mensagens DIRETO do WPPConnect
      const messages = await this.client.getMessages(chatId, {
        count,
        direction: 'before',
      });

      // Formatar mensagens para o formato esperado pelo frontend
      return messages.map((msg: any) => {
        // ✅ CRÍTICO: Usar ACK real do WhatsApp
        const ack = msg.ack !== undefined ? msg.ack : (msg.fromMe ? 1 : -1);
        const status = this.mapAckToStatus(ack);

        logger.debug(`📊 Mensagem ${msg.id?.substring(0, 20)}... - ACK: ${ack} -> Status: ${status}`);

        return {
          id: msg.id,
          conversationId: chatId,
          type: msg.type,
          content: msg.body || '',
          mediaUrl: msg.mediaUrl || null,
          mediaType: msg.mimetype || null,
          fromMe: msg.fromMe || false,
          status,
          ack, // ✅ Incluir ACK original para debug
          timestamp: new Date(msg.timestamp * 1000),
          quotedMessage: msg.quotedMsg ? {
            id: msg.quotedMsg.id,
            content: msg.quotedMsg.body || '',
            fromMe: msg.quotedMsg.fromMe || false,
            contact: {
              id: cleanPhone,
              phone: cleanPhone,
              name: cleanPhone,
            },
          } : null,
          contact: {
            id: cleanPhone,
            phone: cleanPhone,
            name: cleanPhone,
          },
        };
      });
    } catch (error: any) {
      logger.error(`Erro ao buscar mensagens de ${phone}:`, error);
      throw error;
    }
  }

  /**
   * Helper: Mapear ACK do WhatsApp para status
   * ACK codes (padrão WhatsApp Web):
   * -1 = ERROR (erro no envio)
   * 0 = CLOCK (pendente, relógio)
   * 1 = SENT (enviado ao servidor, 1 check cinza)
   * 2 = SENT (recebido pelo servidor, 1 check cinza)
   * 3 = DELIVERED (entregue ao destinatário, 2 checks cinza)
   * 4 = READ (lido pelo destinatário, 2 checks azuis)
   * 5 = PLAYED (áudio/vídeo reproduzido, 2 checks azuis)
   */
  private mapAckToStatus(ack?: number): string {
    switch (ack) {
      case -1: return 'ERROR';
      case 0: return 'PENDING';      // Relógio (aguardando envio)
      case 1: return 'SENT';          // 1 check cinza
      case 2: return 'SENT';          // 1 check cinza (servidor recebeu)
      case 3: return 'DELIVERED';     // 2 checks cinza
      case 4: return 'READ';          // 2 checks azuis
      case 5: return 'PLAYED';        // 2 checks azuis + ícone play
      default: return 'SENT';
    }
  }

  /**
   * Reinicializar conexão WhatsApp (gerar novo QR code)
   */
  async reinitialize(): Promise<void> {
    logger.info('🔄 Reinicializando WhatsApp...');

    // Desconectar sessão atual se existir
    await this.disconnect();

    // Resetar estados
    this.isInitializing = false;
    this.isConnected = false;
    this.qrCode = null;
    this.client = null;

    // Aguardar 2 segundos antes de reiniciar
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Inicializar novamente
    await this.initialize();

    logger.info('✅ WhatsApp reinicializado');
  }

  /**
   * ✅ MELHORIA: Obter status da conexão com informações de WebSocket
   */
  getStatus(): {
    connected: boolean;
    hasQR: boolean;
    message: string;
    isInitializing: boolean;
    socketIO: {
      initialized: boolean;
      connectedClients: number;
    };
  } {
    let message = 'Inicializando...';

    if (this.isConnected) {
      message = 'Conectado';
    } else if (this.qrCode !== null) {
      message = 'Aguardando leitura do QR Code';
    } else if (this.isInitializing) {
      message = 'Inicializando WhatsApp...';
    } else if (this.client === null) {
      message = 'Não inicializado';
    } else {
      message = 'Aguardando QR Code...';
    }

    // ✅ MELHORIA: Incluir informações de WebSocket
    let connectedClients = 0;
    try {
      if (this.io && this.io.engine) {
        connectedClients = this.io.engine.clientsCount || 0;
      }
    } catch (error) {
      // Silencioso - apenas retornar 0
    }

    return {
      connected: this.isConnected,
      hasQR: this.qrCode !== null,
      message,
      isInitializing: this.isInitializing,
      socketIO: {
        initialized: this.io !== null,
        connectedClients,
      },
    };
  }

  /**
   * ✅ FASE 2: Configurar Socket.IO (unificado)
   * Substitui setSocketServer() - agora usa setSocketIO() declarado acima
   * @param io Instância do Socket.IO
   */
  setSocketServer(io: SocketIOServer): void {
    // Configurar Socket.IO no serviço principal
    this.setSocketIO(io);

    // Configurar Socket.IO nos listeners avançados
    if (this.listeners) {
      this.listeners.setSocketServer(io);
      logger.info('✅ Socket.IO configurado para listeners avançados do WhatsApp');
    }
  }
  // ============================================================================
  // 🆕 FUNCIONALIDADES EXTENDED - Métodos do WPPConnect
  // ============================================================================
  // Copiados de whatsappServiceExtended.ts e integrados na classe principal

  // ============================================================================
  // MENSAGENS - TIPOS ADICIONAIS (10 funcionalidades)
  // ============================================================================

  /**
   * 7. Enviar áudio/PTT (Push-to-Talk)
   */
  async sendAudio(to: string, audioPath: string, ptt: boolean = true): Promise<any> {
    try {
      const result = ptt
        ? await this.client.sendPtt(to, audioPath)
        : await this.client.sendFile(to, audioPath, 'audio', '');
      logger.info(`✅ Áudio enviado para ${to}`);
      return result;
    } catch (error) {
      logger.error(`❌ Erro ao enviar áudio:`, error);
      throw error;
    }
  }

  /**
   * 8. Enviar localização GPS
   */
  async sendLocation(to: string, latitude: number, longitude: number, description?: string): Promise<any> {
    try {
      const result = await this.client.sendLocation(to, latitude.toString(), longitude.toString(), description || '');
      logger.info(`✅ Localização enviada para ${to}`);
      return result;
    } catch (error) {
      logger.error(`❌ Erro ao enviar localização:`, error);
      throw error;
    }
  }

  /**
   * 9. Enviar cartão de contato (vCard)
   */
  async sendContactVcard(to: string, contactId: string, name?: string): Promise<any> {
    try {
      const result = await this.client.sendContactVcard(to, contactId, name || '');
      logger.info(`✅ Contato enviado para ${to}`);
      return result;
    } catch (error) {
      logger.error(`❌ Erro ao enviar contato:`, error);
      throw error;
    }
  }

  /**
   * 10. Enviar sticker/figurinha
   */
  async sendSticker(to: string, imagePath: string): Promise<any> {
    try {
      const result = await this.client.sendImageAsSticker(to, imagePath);
      logger.info(`✅ Sticker enviado para ${to}`);
      return result;
    } catch (error) {
      logger.error(`❌ Erro ao enviar sticker:`, error);
      throw error;
    }
  }

  /**
   * 11. Enviar documento/arquivo
   */
  async sendFile(to: string, filePath: string, filename: string, caption?: string): Promise<any> {
    try {
      const result = await this.client.sendFile(to, filePath, filename, caption || '');
      logger.info(`✅ Arquivo enviado para ${to}`);
      return result;
    } catch (error) {
      logger.error(`❌ Erro ao enviar arquivo:`, error);
      throw error;
    }
  }

  /**
   * 12. Enviar link com preview
   */
  async sendLinkPreview(to: string, url: string, title: string): Promise<any> {
    try {
      const result = await this.client.sendLinkPreview(to, url, title);
      logger.info(`✅ Link enviado para ${to}`);
      return result;
    } catch (error) {
      logger.error(`❌ Erro ao enviar link:`, error);
      throw error;
    }
  }

  /**
   * 13. Enviar mensagem de lista interativa
   */
  async sendListMessage(to: string, title: string, description: string, buttonText: string, sections: any[]): Promise<any> {
    try {
      const result = await this.client.sendListMessage(to, {
        buttonText,
        description,
        title,
        sections: sections.map((section: any) => ({
          title: section.title,
          rows: section.rows.map((row: any) => ({
            rowId: row.id || row.rowId,
            title: row.title,
            description: row.description
          }))
        }))
      });
      logger.info(`✅ Lista enviada para ${to}`);
      return result;
    } catch (error) {
      logger.error(`❌ Erro ao enviar lista:`, error);
      throw error;
    }
  }

  /**
   * 14. Enviar mensagem com botões
   */
  async sendButtons(to: string, message: string, buttons: Array<{ id?: string; text: string; url?: string; phoneNumber?: string }>): Promise<any> {
    try {
      const result = await this.client.sendText(to, message, {
        useTemplateButtons: true,
        buttons: buttons.map((btn) => ({
          id: btn.id,
          text: btn.text,
          url: btn.url,
          phoneNumber: btn.phoneNumber
        }))
      });
      logger.info(`✅ Botões enviados para ${to}`);
      return result;
    } catch (error) {
      logger.error(`❌ Erro ao enviar botões:`, error);
      throw error;
    }
  }

  /**
   * 15. Enviar enquete/poll
   */
  async sendPoll(to: string, name: string, options: string[], selectableCount?: number): Promise<any> {
    try {
      const result = await this.client.sendPollMessage(to, name, options, {
        selectableCount: selectableCount || 1
      });
      logger.info(`✅ Enquete enviada para ${to}`);
      return result;
    } catch (error) {
      logger.error(`❌ Erro ao enviar enquete:`, error);
      throw error;
    }
  }

  /**
   * 16. Enviar mensagem de pedido (WhatsApp Business)
   */
  async sendOrderMessage(to: string, items: any[]): Promise<any> {
    try {
      // @ts-ignore - Método pode não estar tipado
      const result = await this.client.sendOrderMessage?.(to, items);
      logger.info(`✅ Pedido enviado para ${to}`);
      return result;
    } catch (error) {
      logger.error(`❌ Erro ao enviar pedido:`, error);
      throw error;
    }
  }

  // ============================================================================
  // GERENCIAMENTO DE CHAT (11 funcionalidades)
  // ============================================================================

  /**
   * 17. Arquivar/desarquivar chat
   */
  async archiveChat(chatId: string, archive: boolean = true): Promise<void> {
    try {
      await this.client.archiveChat(chatId, archive);
      logger.info(`✅ Chat ${archive ? 'arquivado' : 'desarquivado'}: ${chatId}`);
    } catch (error) {
      logger.error('❌ Erro ao arquivar chat:', error);
      throw error;
    }
  }

  /**
   * 18. Fixar/desfixar chat
   */
  async pinChat(chatId: string, pin: boolean = true): Promise<void> {
    try {
      // @ts-ignore
      await this.client.pinChat?.(chatId, pin);
      logger.info(`✅ Chat ${pin ? 'fixado' : 'desfixado'}: ${chatId}`);
    } catch (error) {
      logger.error('❌ Erro ao fixar chat:', error);
      throw error;
    }
  }

  /**
   * 19. Limpar histórico de chat
   */
  async clearChat(chatId: string): Promise<void> {
    try {
      await this.client.clearChat(chatId);
      logger.info(`✅ Chat limpo: ${chatId}`);
    } catch (error) {
      logger.error('❌ Erro ao limpar chat:', error);
      throw error;
    }
  }

  /**
   * 20. Deletar mensagem
   */
  async deleteMessage(chatId: string, messageId: string, onlyLocal: boolean = false): Promise<void> {
    try {
      await this.client.deleteMessage(chatId, [messageId], onlyLocal);
      logger.info(`✅ Mensagem deletada: ${messageId}`);
    } catch (error) {
      logger.error('❌ Erro ao deletar mensagem:', error);
      throw error;
    }
  }

  /**
   * 21. Editar mensagem
   */
  async editMessage(messageId: string, newContent: string): Promise<void> {
    try {
      await this.client.editMessage(messageId, newContent);
      logger.info(`✅ Mensagem editada: ${messageId}`);
    } catch (error) {
      logger.error('❌ Erro ao editar mensagem:', error);
      throw error;
    }
  }

  /**
   * 22. Encaminhar mensagem
   */
  async forwardMessage(to: string, messageId: string): Promise<void> {
    try {
      await this.client.forwardMessage(to, messageId);
      logger.info(`✅ Mensagem encaminhada para ${to}`);
    } catch (error) {
      logger.error('❌ Erro ao encaminhar mensagem:', error);
      throw error;
    }
  }

  /**
   * 23. Marcar como lido
   */
  async markAsRead(chatId: string): Promise<void> {
    try {
      await this.client.sendSeen(chatId);
      logger.info(`✅ Chat marcado como lido: ${chatId}`);
    } catch (error) {
      logger.error('❌ Erro ao marcar como lido:', error);
      throw error;
    }
  }

  /**
   * 24. Reagir a mensagem
   */
  async reactToMessage(messageId: string, emoji: string): Promise<void> {
    try {
      await this.client.sendReactionToMessage(messageId, emoji);
      logger.info(`✅ Reação enviada: ${emoji}`);
    } catch (error) {
      logger.error('❌ Erro ao reagir:', error);
      throw error;
    }
  }

  /**
   * 25. Buscar mensagens
   */
  async searchMessages(query: string, page: number = 1, count: number = 10): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.searchMessages?.(query, page, count);
      logger.info(`✅ Busca realizada: ${query}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao buscar mensagens:', error);
      throw error;
    }
  }

  /**
   * 26. Configurar mensagens temporárias
   */
  async setTemporaryMessages(chatId: string, duration: number): Promise<void> {
    try {
      // @ts-ignore
      await this.client.setTemporaryMessages?.(chatId, duration);
      logger.info(`✅ Mensagens temporárias configuradas: ${chatId}`);
    } catch (error) {
      logger.error('❌ Erro ao configurar mensagens temporárias:', error);
      throw error;
    }
  }

  /**
   * 27. Iniciar "digitando..."
   */
  async startTyping(chatId: string): Promise<void> {
    try {
      await this.client.startTyping(chatId);
      logger.debug(`✅ Digitando iniciado: ${chatId}`);
    } catch (error) {
      logger.error('❌ Erro ao iniciar digitando:', error);
      throw error;
    }
  }

  /**
   * 28. Parar "digitando..."
   */
  async stopTyping(chatId: string): Promise<void> {
    try {
      await this.client.stopTyping(chatId);
      logger.debug(`✅ Digitando parado: ${chatId}`);
    } catch (error) {
      logger.error('❌ Erro ao parar digitando:', error);
      throw error;
    }
  }

  /**
   * 29. Iniciar "gravando áudio..."
   */
  async startRecording(chatId: string): Promise<void> {
    try {
      await this.client.startRecording(chatId);
      logger.debug(`✅ Gravação iniciada: ${chatId}`);
    } catch (error) {
      logger.error('❌ Erro ao iniciar gravação:', error);
      throw error;
    }
  }

  /**
   * 30. Parar "gravando áudio..."
   */
  async stopRecording(chatId: string): Promise<void> {
    try {
      await this.client.stopRecoring(chatId);
      logger.debug(`✅ Gravação parada: ${chatId}`);
    } catch (error) {
      logger.error('❌ Erro ao parar gravação:', error);
      throw error;
    }
  }

  // ============================================================================
  // GRUPOS (15 funcionalidades)
  // ============================================================================

  /**
   * 31. Criar grupo
   */
  async createGroup(groupName: string, contacts: string[]): Promise<any> {
    try {
      const result = await this.client.createGroup(groupName, contacts);
      logger.info(`✅ Grupo criado: ${groupName}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao criar grupo:', error);
      throw error;
    }
  }

  /**
   * 32. Adicionar participantes
   */
  async addParticipants(groupId: string, participants: string[]): Promise<any> {
    try {
      const result = await this.client.addParticipant(groupId, participants);
      logger.info(`✅ Participantes adicionados ao grupo ${groupId}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao adicionar participantes:', error);
      throw error;
    }
  }

  /**
   * 33. Remover participantes
   */
  async removeParticipants(groupId: string, participants: string[]): Promise<any> {
    try {
      const result = await this.client.removeParticipant(groupId, participants);
      logger.info(`✅ Participantes removidos do grupo ${groupId}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao remover participantes:', error);
      throw error;
    }
  }

  /**
   * 34. Promover a admin
   */
  async promoteParticipant(groupId: string, participants: string[]): Promise<any> {
    try {
      const result = await this.client.promoteParticipant(groupId, participants);
      logger.info(`✅ Participantes promovidos a admin: ${groupId}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao promover participantes:', error);
      throw error;
    }
  }

  /**
   * 35. Rebaixar admin
   */
  async demoteParticipant(groupId: string, participants: string[]): Promise<any> {
    try {
      const result = await this.client.demoteParticipant(groupId, participants);
      logger.info(`✅ Participantes rebaixados de admin: ${groupId}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao rebaixar participantes:', error);
      throw error;
    }
  }

  /**
   * 36. Obter link de convite
   */
  async getGroupInviteLink(groupId: string): Promise<string> {
    try {
      const link = await this.client.getGroupInviteLink(groupId);
      logger.info(`✅ Link obtido: ${groupId}`);
      return link;
    } catch (error) {
      logger.error('❌ Erro ao obter link:', error);
      throw error;
    }
  }

  /**
   * 37. Entrar em grupo via link
   */
  async joinGroupViaLink(inviteCode: string): Promise<any> {
    try {
      const result = await this.client.joinGroup(inviteCode);
      logger.info(`✅ Entrou no grupo via link`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao entrar no grupo:', error);
      throw error;
    }
  }

  /**
   * 38. Sair de grupo
   */
  async leaveGroup(groupId: string): Promise<void> {
    try {
      await this.client.leaveGroup(groupId);
      logger.info(`✅ Saiu do grupo: ${groupId}`);
    } catch (error) {
      logger.error('❌ Erro ao sair do grupo:', error);
      throw error;
    }
  }

  /**
   * 39. Alterar nome do grupo
   */
  async setGroupSubject(groupId: string, subject: string): Promise<void> {
    try {
      await this.client.setGroupSubject(groupId, subject);
      logger.info(`✅ Nome do grupo alterado: ${groupId}`);
    } catch (error) {
      logger.error('❌ Erro ao alterar nome:', error);
      throw error;
    }
  }

  /**
   * 40. Alterar descrição do grupo
   */
  async setGroupDescription(groupId: string, description: string): Promise<void> {
    try {
      await this.client.setGroupDescription(groupId, description);
      logger.info(`✅ Descrição do grupo alterada: ${groupId}`);
    } catch (error) {
      logger.error('❌ Erro ao alterar descrição:', error);
      throw error;
    }
  }

  /**
   * 41. Alterar foto do grupo
   */
  async setGroupIcon(groupId: string, imagePath: string): Promise<void> {
    try {
      await this.client.setGroupIcon(groupId, imagePath);
      logger.info(`✅ Foto do grupo alterada: ${groupId}`);
    } catch (error) {
      logger.error('❌ Erro ao alterar foto:', error);
      throw error;
    }
  }

  /**
   * 42. Configurar quem pode enviar mensagens
   */
  async setGroupSettings(groupId: string, onlyAdmins: boolean): Promise<void> {
    try {
      await this.client.setGroupProperty(groupId, GroupProperty.ANNOUNCEMENT, onlyAdmins);
      logger.info(`✅ Configurações do grupo alteradas: ${groupId}`);
    } catch (error) {
      logger.error('❌ Erro ao configurar grupo:', error);
      throw error;
    }
  }

  /**
   * 43. Aprovar solicitação de entrada
   */
  async approveGroupMembershipRequest(groupId: string, membershipRequests: string[]): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.approveGroupMembershipRequest?.(groupId, membershipRequests);
      logger.info(`✅ Solicitações aprovadas: ${groupId}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao aprovar solicitações:', error);
      throw error;
    }
  }

  /**
   * 44. Listar participantes
   */
  async getGroupMembers(groupId: string): Promise<any> {
    try {
      const members = await this.client.getGroupMembers(groupId);
      logger.info(`✅ Participantes listados: ${groupId}`);
      return members;
    } catch (error) {
      logger.error('❌ Erro ao listar participantes:', error);
      throw error;
    }
  }

  /**
   * 45. Listar administradores
   */
  async getGroupAdmins(groupId: string): Promise<any> {
    try {
      const members = await this.client.getGroupMembers(groupId);
      // @ts-ignore
      const admins = members.filter((m: any) => m.isAdmin || m.isSuperAdmin);
      logger.info(`✅ Administradores listados: ${groupId}`);
      return admins;
    } catch (error) {
      logger.error('❌ Erro ao listar admins:', error);
      throw error;
    }
  }

  // ============================================================================
  // CONTATOS (8 funcionalidades)
  // ============================================================================

  /**
   * 46. Verificar se número existe no WhatsApp
   */
  async checkNumberExists(number: string): Promise<any> {
    try {
      const result = await this.client.checkNumberStatus(number);
      logger.info(`✅ Número verificado: ${number}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao verificar número:', error);
      throw error;
    }
  }

  /**
   * 47. Obter detalhes de contato
   */
  async getContact(contactId: string): Promise<any> {
    try {
      const contact = await this.client.getContact(contactId);
      logger.info(`✅ Contato obtido: ${contactId}`);
      return contact;
    } catch (error) {
      logger.error('❌ Erro ao obter contato:', error);
      throw error;
    }
  }

  /**
   * 48. Listar todos os contatos
   */
  async getAllContacts(): Promise<any> {
    try {
      const contacts = await this.client.getAllContacts();
      logger.info(`✅ Contatos listados: ${contacts.length}`);
      return contacts;
    } catch (error) {
      logger.error('❌ Erro ao listar contatos:', error);
      throw error;
    }
  }

  /**
   * 49. Bloquear contato
   */
  async blockContact(contactId: string): Promise<void> {
    try {
      await this.client.blockContact(contactId);
      logger.info(`✅ Contato bloqueado: ${contactId}`);
    } catch (error) {
      logger.error('❌ Erro ao bloquear contato:', error);
      throw error;
    }
  }

  /**
   * 50. Desbloquear contato
   */
  async unblockContact(contactId: string): Promise<void> {
    try {
      await this.client.unblockContact(contactId);
      logger.info(`✅ Contato desbloqueado: ${contactId}`);
    } catch (error) {
      logger.error('❌ Erro ao desbloquear contato:', error);
      throw error;
    }
  }

  /**
   * 51. Obter foto de perfil
   */
  async getProfilePicUrl(contactId: string): Promise<string> {
    try {
      const result = await this.client.getProfilePicFromServer(contactId);
      logger.info(`✅ Foto obtida: ${contactId}`);
      return result.imgFull || result.img || '';
    } catch (error) {
      logger.error('❌ Erro ao obter foto:', error);
      throw error;
    }
  }

  /**
   * 52. Obter status do contato
   */
  async getStatus(contactId: string): Promise<any> {
    try {
      const status = await this.client.getStatus(contactId);
      logger.info(`✅ Status obtido: ${contactId}`);
      return status;
    } catch (error) {
      logger.error('❌ Erro ao obter status:', error);
      throw error;
    }
  }

  /**
   * 53. Listar chats
   */
  async getAllChats(): Promise<any> {
    try {
      const chats = await this.client.getAllChats();
      logger.info(`✅ Chats listados: ${chats.length}`);
      return chats;
    } catch (error) {
      logger.error('❌ Erro ao listar chats:', error);
      throw error;
    }
  }

  // ============================================================================
  // STATUS/STORIES (5 funcionalidades)
  // ============================================================================

  /**
   * 54. Postar status de texto
   */
  async postTextStatus(text: string, options?: any): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.sendTextStatus?.(text, options);
      logger.info(`✅ Status de texto postado`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao postar status de texto:', error);
      throw error;
    }
  }

  /**
   * 55. Postar status de imagem
   */
  async postImageStatus(imagePath: string, caption?: string): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.sendImageStatus?.(imagePath, caption);
      logger.info(`✅ Status de imagem postado`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao postar status de imagem:', error);
      throw error;
    }
  }

  /**
   * 56. Postar status de vídeo
   */
  async postVideoStatus(videoPath: string, caption?: string): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.sendVideoStatus?.(videoPath, caption);
      logger.info(`✅ Status de vídeo postado`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao postar status de vídeo:', error);
      throw error;
    }
  }

  /**
   * 57. Ver status de contatos
   */
  async getAllStatus(): Promise<any> {
    try {
      // @ts-ignore
      const statuses = await this.client.getAllStatus?.();
      logger.info(`✅ Status listados`);
      return statuses;
    } catch (error) {
      logger.error('❌ Erro ao listar status:', error);
      throw error;
    }
  }

  /**
   * 58. Deletar status
   */
  async deleteStatus(statusId: string): Promise<void> {
    try {
      // @ts-ignore
      await this.client.deleteStatus?.(statusId);
      logger.info(`✅ Status deletado: ${statusId}`);
    } catch (error) {
      logger.error('❌ Erro ao deletar status:', error);
      throw error;
    }
  }

  // ============================================================================
  // PERFIL E CONFIGURAÇÕES (7 funcionalidades)
  // ============================================================================

  /**
   * 59. Alterar nome de perfil
   */
  async setProfileName(name: string): Promise<void> {
    try {
      await this.client.setProfileName(name);
      logger.info(`✅ Nome de perfil alterado: ${name}`);
    } catch (error) {
      logger.error('❌ Erro ao alterar nome:', error);
      throw error;
    }
  }

  /**
   * 60. Alterar foto de perfil
   */
  async setProfilePicture(imagePath: string): Promise<void> {
    try {
      await this.client.setProfilePic(imagePath);
      logger.info(`✅ Foto de perfil alterada`);
    } catch (error) {
      logger.error('❌ Erro ao alterar foto:', error);
      throw error;
    }
  }

  /**
   * 61. Alterar status/recado
   */
  async setProfileStatus(status: string): Promise<void> {
    try {
      await this.client.setProfileStatus(status);
      logger.info(`✅ Status de perfil alterado: ${status}`);
    } catch (error) {
      logger.error('❌ Erro ao alterar status:', error);
      throw error;
    }
  }

  /**
   * 62. Configurar presença online
   */
  async setPresenceAvailable(): Promise<void> {
    try {
      // @ts-ignore
      await this.client.setPresenceAvailable?.();
      logger.info(`✅ Presença configurada como disponível`);
    } catch (error) {
      logger.error('❌ Erro ao configurar presença:', error);
      throw error;
    }
  }

  /**
   * 63. Configurar presença ausente
   */
  async setPresenceUnavailable(): Promise<void> {
    try {
      // @ts-ignore
      await this.client.setPresenceUnavailable?.();
      logger.info(`✅ Presença configurada como ausente`);
    } catch (error) {
      logger.error('❌ Erro ao configurar presença:', error);
      throw error;
    }
  }

  /**
   * 64. Obter informações do host
   */
  async getHostDevice(): Promise<any> {
    try {
      const host = await this.client.getHostDevice();
      logger.info(`✅ Informações do host obtidas`);
      return host;
    } catch (error) {
      logger.error('❌ Erro ao obter host:', error);
      throw error;
    }
  }

  /**
   * 65. Obter informações da bateria
   */
  async getBatteryLevel(): Promise<any> {
    try {
      const battery = await this.client.getBatteryLevel();
      logger.info(`✅ Nível de bateria obtido: ${battery}%`);
      return battery;
    } catch (error) {
      logger.error('❌ Erro ao obter bateria:', error);
      throw error;
    }
  }

  // ============================================================================
  // WHATSAPP BUSINESS (10 funcionalidades)
  // ============================================================================

  /**
   * 66. Criar produto no catálogo
   */
  async createProduct(product: any): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.createProduct?.(product);
      logger.info(`✅ Produto criado no catálogo`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao criar produto:', error);
      throw error;
    }
  }

  /**
   * 67. Listar produtos do catálogo
   */
  async getProducts(): Promise<any> {
    try {
      // @ts-ignore
      const products = await this.client.getProducts?.();
      logger.info(`✅ Produtos listados`);
      return products;
    } catch (error) {
      logger.error('❌ Erro ao listar produtos:', error);
      throw error;
    }
  }

  /**
   * 68. Deletar produto
   */
  async deleteProduct(productId: string): Promise<void> {
    try {
      // @ts-ignore
      await this.client.deleteProduct?.(productId);
      logger.info(`✅ Produto deletado: ${productId}`);
    } catch (error) {
      logger.error('❌ Erro ao deletar produto:', error);
      throw error;
    }
  }

  /**
   * 69. Enviar produto do catálogo
   */
  async sendProductFromCatalog(to: string, productId: string): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.sendProductFromCatalog?.(to, productId);
      logger.info(`✅ Produto enviado para ${to}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao enviar produto:', error);
      throw error;
    }
  }

  /**
   * 70. Criar coleção de produtos
   */
  async createCollection(name: string, productIds: string[]): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.createCollection?.(name, productIds);
      logger.info(`✅ Coleção criada: ${name}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao criar coleção:', error);
      throw error;
    }
  }

  /**
   * 71. Criar label/etiqueta
   */
  async createLabel(name: string, color: string): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.addNewLabel?.(name, color);
      logger.info(`✅ Label criada: ${name}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao criar label:', error);
      throw error;
    }
  }

  /**
   * 72. Adicionar label ao chat
   */
  async addLabelToChat(chatId: string, labelId: string): Promise<void> {
    try {
      // @ts-ignore
      await this.client.addOrRemoveLabels?.([labelId], [chatId]);
      logger.info(`✅ Label adicionada ao chat ${chatId}`);
    } catch (error) {
      logger.error('❌ Erro ao adicionar label:', error);
      throw error;
    }
  }

  /**
   * 73. Listar labels
   */
  async getAllLabels(): Promise<any> {
    try {
      // @ts-ignore
      const labels = await this.client.getAllLabels?.();
      logger.info(`✅ Labels listadas`);
      return labels;
    } catch (error) {
      logger.error('❌ Erro ao listar labels:', error);
      throw error;
    }
  }

  /**
   * 74. Configurar mensagem de ausência
   */
  async setAwayMessage(message: string): Promise<void> {
    try {
      // @ts-ignore
      await this.client.setAwayMessage?.(message);
      logger.info(`✅ Mensagem de ausência configurada`);
    } catch (error) {
      logger.error('❌ Erro ao configurar mensagem de ausência:', error);
      throw error;
    }
  }

  /**
   * 75. Configurar mensagem de saudação
   */
  async setGreetingMessage(message: string): Promise<void> {
    try {
      // @ts-ignore
      await this.client.setGreetingMessage?.(message);
      logger.info(`✅ Mensagem de saudação configurada`);
    } catch (error) {
      logger.error('❌ Erro ao configurar mensagem de saudação:', error);
      throw error;
    }
  }

  // ============================================================================
  // COMUNIDADES (4 funcionalidades)
  // ============================================================================

  /**
   * 76. Criar comunidade
   */
  async createCommunity(name: string, description?: string): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.createCommunity?.(name, description);
      logger.info(`✅ Comunidade criada: ${name}`);
      return result;
    } catch (error) {
      logger.error('❌ Erro ao criar comunidade:', error);
      throw error;
    }
  }

  /**
   * 77. Adicionar grupo à comunidade
   */
  async addGroupToCommunity(communityId: string, groupId: string): Promise<void> {
    try {
      // @ts-ignore
      await this.client.addGroupToCommunity?.(communityId, groupId);
      logger.info(`✅ Grupo adicionado à comunidade ${communityId}`);
    } catch (error) {
      logger.error('❌ Erro ao adicionar grupo:', error);
      throw error;
    }
  }

  /**
   * 78. Remover grupo da comunidade
   */
  async removeGroupFromCommunity(communityId: string, groupId: string): Promise<void> {
    try {
      // @ts-ignore
      await this.client.removeGroupFromCommunity?.(communityId, groupId);
      logger.info(`✅ Grupo removido da comunidade ${communityId}`);
    } catch (error) {
      logger.error('❌ Erro ao remover grupo:', error);
      throw error;
    }
  }

  /**
   * 79. Listar comunidades
   */
  async getAllCommunities(): Promise<any> {
    try {
      // @ts-ignore
      const communities = await this.client.getAllCommunities?.();
      logger.info(`✅ Comunidades listadas`);
      return communities;
    } catch (error) {
      logger.error('❌ Erro ao listar comunidades:', error);
      throw error;
    }
  }

  // ============================================================================
  // UTILITÁRIOS (9 funcionalidades)
  // ============================================================================

  /**
   * 80. Baixar mídia de mensagem
   */
  async downloadMedia(messageId: string): Promise<Buffer> {
    try {
      const buffer = await this.client.downloadMedia(messageId);
      logger.info(`✅ Mídia baixada: ${messageId}`);
      return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer as string, 'base64');
    } catch (error) {
      logger.error('❌ Erro ao baixar mídia:', error);
      throw error;
    }
  }

  /**
   * 81. Obter informações de mensagem
   */
  async getMessageById(messageId: string): Promise<any> {
    try {
      const message = await this.client.getMessageById(messageId);
      logger.info(`✅ Mensagem obtida: ${messageId}`);
      return message;
    } catch (error) {
      logger.error('❌ Erro ao obter mensagem:', error);
      throw error;
    }
  }

  /**
   * 82. Capturar screenshot
   */
  async takeScreenshot(): Promise<string> {
    try {
      // @ts-ignore
      const screenshot = await this.client.takeScreenshot?.();
      logger.info(`✅ Screenshot capturado`);
      return screenshot;
    } catch (error) {
      logger.error('❌ Erro ao capturar screenshot:', error);
      throw error;
    }
  }

  /**
   * 83. Obter informações da conexão
   */
  async getConnectionState(): Promise<any> {
    try {
      const state = await this.client.getConnectionState();
      logger.info(`✅ Estado da conexão obtido`);
      return state;
    } catch (error) {
      logger.error('❌ Erro ao obter estado:', error);
      throw error;
    }
  }

  /**
   * 84. Obter WAVersion
   */
  async getWAVersion(): Promise<string> {
    try {
      const version = await this.client.getWAVersion();
      logger.info(`✅ Versão do WhatsApp: ${version}`);
      return version;
    } catch (error) {
      logger.error('❌ Erro ao obter versão:', error);
      throw error;
    }
  }

  /**
   * 85. Obter número de mensagens não lidas
   */
  async getUnreadMessages(): Promise<any> {
    try {
      // @ts-ignore
      const unread = await this.client.getUnreadMessages?.();
      logger.info(`✅ Mensagens não lidas obtidas`);
      return unread;
    } catch (error) {
      logger.error('❌ Erro ao obter não lidas:', error);
      throw error;
    }
  }

  /**
   * 86. Sincronizar contatos
   */
  async syncContacts(): Promise<void> {
    try {
      // @ts-ignore
      await this.client.syncContacts?.();
      logger.info(`✅ Contatos sincronizados`);
    } catch (error) {
      logger.error('❌ Erro ao sincronizar contatos:', error);
      throw error;
    }
  }

  /**
   * 87. Logout
   */
  async logout(): Promise<void> {
    try {
      await this.client.logout();
      logger.info(`✅ Logout realizado`);
    } catch (error) {
      logger.error('❌ Erro ao fazer logout:', error);
      throw error;
    }
  }

  /**
   * 88. Restart
   */
  async restart(): Promise<void> {
    try {
      // @ts-ignore
      await this.client.restartService?.();
      logger.info(`✅ Serviço reiniciado`);
    } catch (error) {
      logger.error('❌ Erro ao reiniciar:', error);
      throw error;
    }
  }

  // ============================================================================
  // 🆕 MÉTODOS ADICIONAIS (46 funcionalidades únicas)
  // ============================================================================

  async sendContactVcardList(to: string, contacts: (string | { id: string; name: string })[]): Promise<any> {
    try {
      const result = await this.client.sendContactVcardList(to, contacts);
      logger.info(`👥 Lista de contatos enviada para ${to}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar lista de contatos:', error);
      throw error;
    }
  }

  async sendGif(to: string, filePath: string, filename?: string, caption?: string): Promise<any> {
    try {
      const result = await this.client.sendGif(to, filePath, filename, caption);
      logger.info(`🎬 GIF enviado para ${to}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar GIF:', error);
      throw error;
    }
  }

  async sendGifFromBase64(to: string, base64: string, filename: string, caption?: string): Promise<any> {
    try {
      const result = await this.client.sendGifFromBase64(to, base64, filename, caption);
      logger.info(`🎬 GIF (base64) enviado para ${to}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar GIF base64:', error);
      throw error;
    }
  }

  async sendVideoAsGif(to: string, filePath: string, filename?: string, caption?: string): Promise<any> {
    try {
      const result = await this.client.sendVideoAsGif(to, filePath, filename, caption);
      logger.info(`🎬 Vídeo como GIF enviado para ${to}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar vídeo como GIF:', error);
      throw error;
    }
  }

  async sendVideoAsGifFromBase64(to: string, base64: string, filename: string, caption?: string, quotedMessageId?: string): Promise<any> {
    try {
      const result = await this.client.sendVideoAsGifFromBase64(to, base64, filename, caption, quotedMessageId);
      logger.info(`🎬 Vídeo como GIF (base64) enviado para ${to}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar vídeo como GIF base64:', error);
      throw error;
    }
  }

  async sendImageFromBase64(to: string, base64: string, filename: string, caption?: string, quotedMessageId?: string, isViewOnce?: boolean, mentionedList?: any, options?: { msgId?: string }): Promise<any> {
    try {
      const result = await this.client.sendImageFromBase64(to, base64, filename, caption, quotedMessageId, isViewOnce, mentionedList, options);
      logger.info(`🖼️ Imagem (base64) enviada para ${to}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar imagem base64:', error);
      throw error;
    }
  }

  async sendImageAsSticker(to: string, pathOrBase64: string, options?: any): Promise<any> {
    try {
      const result = await this.client.sendImageAsSticker(to, pathOrBase64, options);
      logger.info(`🎨 Sticker enviado para ${to}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar sticker:', error);
      throw error;
    }
  }

  async sendImageAsStickerGif(to: string, pathOrBase64: string, options?: any): Promise<any> {
    try {
      const result = await this.client.sendImageAsStickerGif(to, pathOrBase64, options);
      logger.info(`🎨 Sticker GIF enviado para ${to}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar sticker GIF:', error);
      throw error;
    }
  }

  async sendPttFromBase64(to: string, base64: string, filename: string, caption?: string, quotedMessageId?: string, messageId?: string): Promise<any> {
    try {
      const result = await this.client.sendPttFromBase64(to, base64, filename, caption, quotedMessageId, messageId);
      logger.info(`🎤 PTT (base64) enviado para ${to}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar PTT base64:', error);
      throw error;
    }
  }

  async sendPixKey(to: string, params: any, options?: any): Promise<any> {
    try {
      const result = await this.client.sendPixKey(to, params, options);
      logger.info(`💰 Chave PIX enviada para ${to}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar chave PIX:', error);
      throw error;
    }
  }

  async sendMessageOptions(chat: any, content: any, options?: any): Promise<any> {
    try {
      const result = await this.client.sendMessageOptions(chat, content, options);
      logger.info(`📤 Mensagem com opções enviada`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar mensagem com opções:', error);
      throw error;
    }
  }

  async reply(to: string, content: string, quotedMsg: string): Promise<any> {
    try {
      const result = await this.client.reply(to, content, quotedMsg);
      logger.info(`↩️ Resposta enviada para ${to}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao responder mensagem:', error);
      throw error;
    }
  }

  async sendImageStatus(pathOrBase64: string, options?: any): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.sendImageStatus?.(pathOrBase64, options);
      logger.info(`📸 Status de imagem postado`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao postar status de imagem:', error);
      throw error;
    }
  }

  async sendVideoStatus(pathOrBase64: string, options?: any): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.sendVideoStatus?.(pathOrBase64, options);
      logger.info(`🎥 Status de vídeo postado`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao postar status de vídeo:', error);
      throw error;
    }
  }

  async sendTextStatus(text: string, options?: any): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.sendTextStatus?.(text, options);
      logger.info(`📝 Status de texto postado`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao postar status de texto:', error);
      throw error;
    }
  }

  async sendReadStatus(statusId: string): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.sendReadStatus?.(statusId);
      logger.info(`✅ Confirmação de leitura de status enviada`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao enviar confirmação de leitura:', error);
      throw error;
    }
  }

  async setChatState(chatId: string, chatState: any): Promise<void> {
    try {
      await this.client.setChatState(chatId, chatState);
      logger.info(`⌨️ Estado do chat definido: ${chatId}`);
    } catch (error: any) {
      logger.error('Erro ao definir estado do chat:', error);
      throw error;
    }
  }

  async setProfilePic(pathOrBase64: string): Promise<any> {
    try {
      const result = await this.client.setProfilePic(pathOrBase64);
      logger.info(`📸 Foto de perfil atualizada`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao atualizar foto de perfil:', error);
      throw error;
    }
  }

  async getAllUnreadMessages(): Promise<any> {
    try {
      const result = await this.client.getAllUnreadMessages();
      logger.info(`📬 Mensagens não lidas obtidas`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter mensagens não lidas:', error);
      throw error;
    }
  }

  async getBlockList(): Promise<any> {
    try {
      const result = await this.client.getBlockList();
      logger.info(`🚫 Lista de bloqueados obtida`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter lista de bloqueados:', error);
      throw error;
    }
  }

  async getChatById(chatId: string): Promise<any> {
    try {
      const result = await this.client.getChatById(chatId);
      logger.info(`💬 Chat obtido: ${chatId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter chat:', error);
      throw error;
    }
  }

  async getChatIsOnline(chatId: string): Promise<boolean> {
    try {
      const result = await this.client.getChatIsOnline(chatId);
      logger.info(`🟢 Status online verificado: ${chatId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao verificar status online:', error);
      throw error;
    }
  }

  async getLastSeen(chatId: string): Promise<any> {
    try {
      const result = await this.client.getLastSeen(chatId);
      logger.info(`🕐 Última vez visto obtido: ${chatId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter última vez visto:', error);
      throw error;
    }
  }

  async getProfilePicFromServer(contactId: string): Promise<any> {
    try {
      const result = await this.client.getProfilePicFromServer(contactId);
      logger.info(`📸 Foto de perfil obtida: ${contactId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter foto de perfil:', error);
      throw error;
    }
  }

  async getReactions(messageId: string): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.getReactions?.(messageId);
      logger.info(`❤️ Reações obtidas da mensagem ${messageId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter reações:', error);
      throw error;
    }
  }

  async getPlatformFromMessage(messageId: string): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.getPlatformFromMessage?.(messageId);
      logger.info(`📱 Plataforma obtida da mensagem ${messageId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter plataforma:', error);
      throw error;
    }
  }

  async getVotes(messageId: string): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.getVotes?.(messageId);
      logger.info(`🗳️ Votos obtidos da enquete ${messageId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter votos:', error);
      throw error;
    }
  }

  async getMessageById(messageId: string): Promise<any> {
    try {
      const result = await this.client.getMessageById(messageId);
      logger.info(`✉️ Mensagem obtida: ${messageId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter mensagem:', error);
      throw error;
    }
  }

  async decryptFile(buffer: any): Promise<Buffer> {
    try {
      const result = await this.client.decryptMedia(buffer);
      logger.info(`🔓 Arquivo descriptografado`);
      return Buffer.isBuffer(result) ? result : Buffer.from(result as string, 'base64');
    } catch (error: any) {
      logger.error('Erro ao descriptografar arquivo:', error);
      throw error;
    }
  }

  async addNewLabel(name: string): Promise<any> {
    try {
      const result = await this.client.addNewLabel(name);
      logger.info(`🏷️ Nova label criada: ${name}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao criar label:', error);
      throw error;
    }
  }

  async deleteLabel(labelId: string): Promise<any> {
    try {
      const result = await this.client.deleteLabel(labelId);
      logger.info(`🗑️ Label deletada: ${labelId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao deletar label:', error);
      throw error;
    }
  }

  async addOrRemoveLabels(chatId: string, labelIds: string[], type: 'add' | 'remove'): Promise<any> {
    try {
      const options = labelIds.map(labelId => ({ labelId, type }));
      const result = await this.client.addOrRemoveLabels(chatId, options);
      logger.info(`🏷️ Labels ${type === 'add' ? 'adicionadas' : 'removidas'} do chat ${chatId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao adicionar/remover labels:', error);
      throw error;
    }
  }

  async getLabels(): Promise<any[]> {
    try {
      return await this.client.getAllLabels();
    } catch (error: any) {
      logger.error('Erro ao obter labels:', error);
      throw error;
    }
  }

  async getOrder(messageId: string): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.getOrder?.(messageId);
      logger.info(`🛒 Pedido obtido: ${messageId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter pedido:', error);
      throw error;
    }
  }

  async getProductById(productId: string): Promise<any> {
    try {
      const result = await this.client.getProductById(productId);
      logger.info(`📦 Produto obtido: ${productId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter produto:', error);
      throw error;
    }
  }

  async editProduct(productId: string, product: any): Promise<any> {
    try {
      const result = await this.client.editProduct(productId, product);
      logger.info(`✏️ Produto editado: ${productId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao editar produto:', error);
      throw error;
    }
  }

  async delProducts(productIds: string[]): Promise<any> {
    try {
      const result = await this.client.delProducts(productIds);
      logger.info(`🗑️ Produtos deletados: ${productIds.length}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao deletar produtos:', error);
      throw error;
    }
  }

  async addSubgroupsCommunity(communityId: string, groupIds: string[]): Promise<any> {
    try {
      const result = await this.client.addSubgroupsCommunity(communityId, groupIds);
      logger.info(`➕ Subgrupos adicionados à comunidade ${communityId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao adicionar subgrupos:', error);
      throw error;
    }
  }

  async removeSubgroupsCommunity(communityId: string, groupIds: string[]): Promise<any> {
    try {
      const result = await this.client.removeSubgroupsCommunity(communityId, groupIds);
      logger.info(`➖ Subgrupos removidos da comunidade ${communityId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao remover subgrupos:', error);
      throw error;
    }
  }

  async promoteCommunityParticipant(communityId: string, participantId: string): Promise<any> {
    try {
      const result = await this.client.promoteCommunityParticipant(communityId, participantId);
      logger.info(`⬆️ Participante promovido na comunidade ${communityId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao promover participante:', error);
      throw error;
    }
  }

  async demoteCommunityParticipant(communityId: string, participantId: string): Promise<any> {
    try {
      const result = await this.client.demoteCommunityParticipant(communityId, participantId);
      logger.info(`⬇️ Participante rebaixado na comunidade ${communityId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao rebaixar participante:', error);
      throw error;
    }
  }

  async getCommunityParticipants(communityId: string): Promise<any> {
    try {
      const result = await this.client.getCommunityParticipants(communityId);
      logger.info(`👥 Participantes da comunidade obtidos: ${communityId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter participantes da comunidade:', error);
      throw error;
    }
  }

  async deactivateCommunity(communityId: string): Promise<any> {
    try {
      const result = await this.client.deactivateCommunity(communityId);
      logger.info(`🔴 Comunidade desativada: ${communityId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao desativar comunidade:', error);
      throw error;
    }
  }

  async rejectCall(callId: string): Promise<any> {
    try {
      const result = await this.client.rejectCall(callId);
      logger.info(`📵 Chamada rejeitada: ${callId}`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao rejeitar chamada:', error);
      throw error;
    }
  }

  async getSessionTokenBrowser(): Promise<any> {
    try {
      const result = await this.client.getSessionTokenBrowser();
      logger.info(`🔑 Token de sessão obtido`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter token:', error);
      throw error;
    }
  }

  async getTheme(): Promise<any> {
    try {
      const result = await this.client.getTheme();
      logger.info(`🎨 Tema obtido`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao obter tema:', error);
      throw error;
    }
  }

  async useHere(): Promise<any> {
    try {
      // @ts-ignore
      const result = await this.client.useHere?.();
      logger.info(`📍 Presença marcada (useHere)`);
      return result;
    } catch (error: any) {
      logger.error('Erro ao marcar presença:', error);
      throw error;
    }
  }

  async close(): Promise<void> {
    try {
      await this.client.close();
      logger.info(`🔴 Cliente encerrado`);
    } catch (error: any) {
      logger.error('Erro ao encerrar:', error);
      throw error;
    }
  }
}

// Exportar instância única (Singleton)
export const whatsappService = new WhatsAppService();
